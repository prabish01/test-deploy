import * as R from "remeda";
import { createValidator } from "remix-validated-form";
import { stringToPathArray } from "set-get";
const getIssuesForError = (err) => {
    return err.issues.flatMap((issue) => {
        if ("unionErrors" in issue) {
            return issue.unionErrors.flatMap((err) => getIssuesForError(err));
        }
        else {
            return [issue];
        }
    });
};
function pathToString(array) {
    return array.reduce(function (string, item) {
        const prefix = string === "" ? "" : ".";
        return string + (isNaN(Number(item)) ? prefix + item : "[" + item + "]");
    }, "");
}
/**
 * Create a validator using a `zod` schema.
 */
export function withZod(zodSchema, parseParams) {
    return createValidator({
        validate: async (value) => {
            const result = await zodSchema.safeParseAsync(value, parseParams);
            if (result.success)
                return { data: result.data, error: undefined };
            const fieldErrors = {};
            getIssuesForError(result.error).forEach((issue) => {
                const path = pathToString(issue.path);
                if (!fieldErrors[path])
                    fieldErrors[path] = issue.message;
            });
            return { error: fieldErrors, data: undefined };
        },
        validateField: async (data, field) => {
            var _a;
            const result = await zodSchema.safeParseAsync(data, parseParams);
            if (result.success)
                return { error: undefined };
            return {
                error: (_a = getIssuesForError(result.error).find((issue) => R.equals(issue.path, stringToPathArray(field)))) === null || _a === void 0 ? void 0 : _a.message,
            };
        },
    });
}
