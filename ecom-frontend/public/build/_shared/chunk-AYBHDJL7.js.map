{
  "version": 3,
  "sources": ["empty-module:@remix-run/cloudflare", "../../../app/utils/platform-adapter.ts", "../../../app/sessions.ts", "../../../app/graphqlWrapper.ts"],
  "sourcesContent": ["module.exports = {};", "// REMIX HMR BEGIN\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\nimport.meta.hot = __hmr__.createHotContext(\n//@ts-expect-error\n\"app/utils/platform-adapter.ts\"\n);\nimport.meta.hot.lastModified = \"1745508918463.9045\";\n}\n// REMIX HMR END\n\nexport const IS_CF_PAGES = typeof process === 'undefined';\n\n// This hack is to prevent `node` modules/packages being bundled in the\n// Cloudflare Pages context, which causes an error.\nexport async function safeRequireNodeDependency(module: string) {\n  return import(module.split('').join(''));\n}\n", "// REMIX HMR BEGIN\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\nimport.meta.hot = __hmr__.createHotContext(\n//@ts-expect-error\n\"app/sessions.ts\"\n);\nimport.meta.hot.lastModified = \"1745508918463.2332\";\n}\n// REMIX HMR END\n\nimport {\n  IS_CF_PAGES,\n  safeRequireNodeDependency,\n} from '~/utils/platform-adapter';\nimport { SessionStorage } from '@remix-run/server-runtime/dist/sessions';\nimport { ErrorResult } from '~/generated/graphql';\nimport { createCookieSessionStorage } from '@remix-run/cloudflare';\nimport { CreateCookieSessionStorageFunction } from '@remix-run/server-runtime';\n\nasync function getCookieSessionStorageFactory(): Promise<CreateCookieSessionStorageFunction> {\n  if (IS_CF_PAGES) {\n    return createCookieSessionStorage;\n  } else {\n    return safeRequireNodeDependency('@remix-run/node').then(\n      (module) => module.createCookieSessionStorage,\n    );\n  }\n}\nlet sessionStorage: SessionStorage<\n  { activeOrderError: ErrorResult } & Record<string, any>\n>;\n\nexport async function getSessionStorage() {\n  if (sessionStorage) {\n    return sessionStorage;\n  }\n  const factory = await getCookieSessionStorageFactory();\n  sessionStorage = factory({\n    cookie: {\n      name: 'vendure_remix_session',\n      httpOnly: true,\n      path: '/',\n      sameSite: 'lax',\n      secrets: ['awdbhbjahdbaw'],\n    },\n  });\n  return sessionStorage;\n}\n", "// REMIX HMR BEGIN\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\nimport.meta.hot = __hmr__.createHotContext(\n//@ts-expect-error\n\"app/graphqlWrapper.ts\"\n);\nimport.meta.hot.lastModified = \"1745508918459.5808\";\n}\n// REMIX HMR END\n\nimport { DocumentNode, print } from 'graphql';\nimport { API_URL } from './constants';\nimport { getSdk } from './generated/graphql';\nimport { getSessionStorage } from './sessions';\n\nexport interface QueryOptions {\n  request: Request;\n}\n\nexport interface GraphqlResponse<Response> {\n  errors: any[];\n  data: Response;\n}\n\nexport type WithHeaders<T> = T & { _headers: Headers };\n\nconst AUTH_TOKEN_SESSION_KEY = 'authToken';\n\nasync function sendQuery<Response, Variables = {}>(options: {\n  query: string;\n  variables?: Variables;\n  headers?: Headers;\n  request?: Request;\n}): Promise<GraphqlResponse<Response> & { headers: Headers }> {\n  const headers = new Headers(options.headers);\n  const req = options.request;\n  headers.append('Content-Type', 'application/json');\n  const session = await getSessionStorage().then((sessionStorage) =>\n    sessionStorage.getSession(options.request?.headers.get('Cookie')),\n  );\n  if (session) {\n    // If we have a vendure auth token stored in the Remix session, then we\n    // add it as a bearer token to the API request being sent to Vendure.\n    const token = session.get(AUTH_TOKEN_SESSION_KEY);\n    if (token) {\n      headers.append('Authorization', `Bearer ${token}`);\n    }\n  }\n\n  return fetch(API_URL, {\n    method: 'POST',\n    body: JSON.stringify(options),\n    headers,\n  }).then(async (res) => ({\n    ...(await res.json()),\n    headers: res.headers,\n  }));\n}\n\nconst baseSdk = getSdk<QueryOptions, unknown>(requester);\n\ntype Sdk = typeof baseSdk;\ntype SdkWithHeaders = {\n  [k in keyof Sdk]: (\n    ...args: Parameters<Sdk[k]>\n  ) => Promise<Awaited<ReturnType<Sdk[k]>> & { _headers: Headers }>;\n};\n\nexport const sdk: SdkWithHeaders = baseSdk as any;\n\nfunction requester<R, V>(\n  doc: DocumentNode,\n  vars?: V,\n  options?: { headers?: Headers; request?: Request },\n): Promise<R & { _headers: Headers }> {\n  return sendQuery<R, V>({\n    query: print(doc),\n    variables: vars,\n    ...options,\n  }).then(async (response) => {\n    const token = response.headers.get('vendure-auth-token');\n    const headers: Record<string, string> = {};\n    if (token) {\n      // If Vendure responded with an auth token, it means a new Vendure session\n      // has started. In this case, we will store that auth token in the Remix session\n      // so that we can attach it as an Authorization header in all subsequent requests.\n      const sessionStorage = await getSessionStorage();\n      const session = await sessionStorage.getSession(\n        options?.request?.headers.get('Cookie'),\n      );\n      if (session) {\n        session.set(AUTH_TOKEN_SESSION_KEY, token);\n        headers['Set-Cookie'] = await sessionStorage.commitSession(session);\n      }\n    }\n    headers['x-vendure-api-url'] = API_URL;\n    if (response.errors) {\n      console.log(\n        response.errors[0].extensions?.exception?.stacktrace.join('\\n') ??\n          response.errors,\n      );\n      throw new Error(JSON.stringify(response.errors[0]));\n    }\n    return { ...response.data, _headers: new Headers(headers) };\n  });\n}\n"],
  "mappings": "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",
  "names": ["sessionStorage"]
}
