{"version":3,"sources":["../src/index.ts","../src/hooks.ts","../src/internal/getInputProps.ts","../src/internal/logic/getCheckboxChecked.ts","../src/internal/logic/getRadioChecked.ts","../src/internal/hooks.ts","../../set-get/src/stringToPathArray.ts","../../set-get/src/setPath.ts","../../set-get/src/getPath.ts","../src/internal/constants.ts","../src/internal/formContext.ts","../src/internal/hydratable.ts","../src/internal/state/createFormStore.ts","../src/internal/logic/requestSubmit.ts","../src/internal/state/arrayUtil.ts","../src/internal/state/storeHooks.ts","../src/internal/state/controlledFields.ts","../src/server.ts","../src/ValidatedForm.tsx","../src/internal/MultiValueMap.ts","../src/internal/submissionCallbacks.ts","../src/internal/util.ts","../src/validation/createValidator.ts","../src/internal/flatten.ts","../src/userFacingFormContext.ts","../src/unreleased/formStateHooks.ts","../src/internal/state/fieldArray.tsx"],"sourcesContent":["export * from \"./hooks\";\nexport * from \"./server\";\nexport * from \"./ValidatedForm\";\nexport * from \"./validation/types\";\nexport * from \"./validation/createValidator\";\nexport * from \"./userFacingFormContext\";\nexport {\n  FieldArray,\n  useFieldArray,\n  type FieldArrayProps,\n  type FieldArrayHelpers,\n} from \"./internal/state/fieldArray\";\n","import { useEffect, useMemo } from \"react\";\nimport {\n  createGetInputProps,\n  GetInputProps,\n  ValidationBehaviorOptions,\n} from \"./internal/getInputProps\";\nimport {\n  useInternalFormContext,\n  useFieldTouched,\n  useFieldError,\n  useFieldDefaultValue,\n  useClearError,\n  useInternalIsSubmitting,\n  useInternalIsValid,\n  useInternalHasBeenSubmitted,\n  useRegisterReceiveFocus,\n  useSmartValidate,\n} from \"./internal/hooks\";\nimport {\n  useControllableValue,\n  useUpdateControllableValue,\n} from \"./internal/state/controlledFields\";\n\n/**\n * Returns whether or not the parent form is currently being submitted.\n * This is different from Remix's `useNavigation()` in that it\n * is aware of what form it's in and when _that_ form is being submitted.\n *\n * @param formId\n */\nexport const useIsSubmitting = (formId?: string) => {\n  const formContext = useInternalFormContext(formId, \"useIsSubmitting\");\n  return useInternalIsSubmitting(formContext.formId);\n};\n\n/**\n * Returns whether or not the current form is valid.\n *\n * @param formId the id of the form. Only necessary if being used outside a ValidatedForm.\n */\nexport const useIsValid = (formId?: string) => {\n  const formContext = useInternalFormContext(formId, \"useIsValid\");\n  return useInternalIsValid(formContext.formId);\n};\n\nexport type FieldProps = {\n  /**\n   * The validation error message if there is one.\n   */\n  error?: string;\n  /**\n   * Clears the error message.\n   */\n  clearError: () => void;\n  /**\n   * Validates the field.\n   */\n  validate: () => void;\n  /**\n   * The default value of the field, if there is one.\n   */\n  defaultValue?: any;\n  /**\n   * Whether or not the field has been touched.\n   */\n  touched: boolean;\n  /**\n   * Helper to set the touched state of the field.\n   */\n  setTouched: (touched: boolean) => void;\n  /**\n   * Helper to get all the props necessary for a regular input.\n   */\n  getInputProps: GetInputProps;\n};\n\n/**\n * Provides the data and helpers necessary to set up a field.\n */\nexport const useField = (\n  name: string,\n  options?: {\n    /**\n     * Allows you to configure a custom function that will be called\n     * when the input needs to receive focus due to a validation error.\n     * This is useful for custom components that use a hidden input.\n     */\n    handleReceiveFocus?: () => void;\n    /**\n     * Allows you to specify when a field gets validated (when using getInputProps)\n     */\n    validationBehavior?: Partial<ValidationBehaviorOptions>;\n    /**\n     * The formId of the form you want to use.\n     * This is not necesary if the input is used inside a form.\n     */\n    formId?: string;\n  }\n): FieldProps => {\n  const { formId: providedFormId, handleReceiveFocus } = options ?? {};\n  const formContext = useInternalFormContext(providedFormId, \"useField\");\n\n  const defaultValue = useFieldDefaultValue(name, formContext);\n  const [touched, setTouched] = useFieldTouched(name, formContext);\n  const error = useFieldError(name, formContext);\n  const clearError = useClearError(formContext);\n\n  const hasBeenSubmitted = useInternalHasBeenSubmitted(formContext.formId);\n  const smartValidate = useSmartValidate(formContext.formId);\n  const registerReceiveFocus = useRegisterReceiveFocus(formContext.formId);\n\n  useEffect(() => {\n    if (handleReceiveFocus)\n      return registerReceiveFocus(name, handleReceiveFocus);\n  }, [handleReceiveFocus, name, registerReceiveFocus]);\n\n  const field = useMemo<FieldProps>(() => {\n    const helpers = {\n      error,\n      clearError: () => clearError(name),\n      validate: () => smartValidate({ alwaysIncludeErrorsFromFields: [name] }),\n      defaultValue,\n      touched,\n      setTouched,\n    };\n    const getInputProps = createGetInputProps({\n      ...helpers,\n      name,\n      hasBeenSubmitted,\n      validationBehavior: options?.validationBehavior,\n    });\n    return {\n      ...helpers,\n      getInputProps,\n    };\n  }, [\n    error,\n    clearError,\n    defaultValue,\n    touched,\n    setTouched,\n    name,\n    hasBeenSubmitted,\n    options?.validationBehavior,\n    smartValidate,\n  ]);\n\n  return field;\n};\n\nexport const useControlField = <T>(name: string, formId?: string) => {\n  const context = useInternalFormContext(formId, \"useControlField\");\n  const [value, setValue] = useControllableValue(context, name);\n  return [value as T, setValue as (value: T) => void] as const;\n};\n\nexport const useUpdateControlledField = (formId?: string) => {\n  const context = useInternalFormContext(formId, \"useControlField\");\n  return useUpdateControllableValue(context.formId);\n};\n","import * as R from \"remeda\";\nimport { getCheckboxChecked } from \"./logic/getCheckboxChecked\";\nimport { getRadioChecked } from \"./logic/getRadioChecked\";\n\nexport type ValidationBehavior = \"onBlur\" | \"onChange\" | \"onSubmit\";\n\nexport type ValidationBehaviorOptions = {\n  initial: ValidationBehavior;\n  whenTouched: ValidationBehavior;\n  whenSubmitted: ValidationBehavior;\n};\n\nexport type CreateGetInputPropsOptions = {\n  clearError: () => void;\n  validate: () => void;\n  defaultValue?: any;\n  touched: boolean;\n  setTouched: (touched: boolean) => void;\n  hasBeenSubmitted: boolean;\n  validationBehavior?: Partial<ValidationBehaviorOptions>;\n  name: string;\n};\n\ntype HandledProps = \"name\" | \"defaultValue\" | \"defaultChecked\";\ntype Callbacks = \"onChange\" | \"onBlur\";\n\ntype MinimalInputProps = {\n  onChange?: ((...args: any[]) => void) | undefined;\n  onBlur?: ((...args: any[]) => void) | undefined;\n  defaultValue?: any;\n  defaultChecked?: boolean | undefined;\n  name?: string | undefined;\n  type?: string | undefined;\n};\n\nexport type GetInputProps = <T extends MinimalInputProps>(\n  props?: Omit<T, HandledProps | Callbacks> & Partial<Pick<T, Callbacks>>\n) => T;\n\nconst defaultValidationBehavior: ValidationBehaviorOptions = {\n  initial: \"onBlur\",\n  whenTouched: \"onChange\",\n  whenSubmitted: \"onChange\",\n};\n\nexport const createGetInputProps = ({\n  clearError,\n  validate,\n  defaultValue,\n  touched,\n  setTouched,\n  hasBeenSubmitted,\n  validationBehavior,\n  name,\n}: CreateGetInputPropsOptions): GetInputProps => {\n  const validationBehaviors = {\n    ...defaultValidationBehavior,\n    ...validationBehavior,\n  };\n\n  return <T extends MinimalInputProps>(props = {} as any) => {\n    const behavior = hasBeenSubmitted\n      ? validationBehaviors.whenSubmitted\n      : touched\n      ? validationBehaviors.whenTouched\n      : validationBehaviors.initial;\n\n    const inputProps: MinimalInputProps = {\n      ...props,\n      onChange: (...args: unknown[]) => {\n        if (behavior === \"onChange\") validate();\n        else clearError();\n        return props?.onChange?.(...args);\n      },\n      onBlur: (...args: unknown[]) => {\n        if (behavior === \"onBlur\") validate();\n        setTouched(true);\n        return props?.onBlur?.(...args);\n      },\n      name,\n    };\n\n    if (props.type === \"checkbox\") {\n      inputProps.defaultChecked = getCheckboxChecked(props.value, defaultValue);\n    } else if (props.type === \"radio\") {\n      inputProps.defaultChecked = getRadioChecked(props.value, defaultValue);\n    } else if (props.value === undefined) {\n      // We should only set the defaultValue if the input is uncontrolled.\n      inputProps.defaultValue = defaultValue;\n    }\n\n    return R.omitBy(inputProps, (value) => value === undefined) as T;\n  };\n};\n","export const getCheckboxChecked = (\n  checkboxValue: string | undefined = \"on\",\n  newValue: unknown\n): boolean | undefined => {\n  if (Array.isArray(newValue))\n    return newValue.some((val) => val === true || val === checkboxValue);\n  if (typeof newValue === \"boolean\") return newValue;\n  if (typeof newValue === \"string\") return newValue === checkboxValue;\n  return undefined;\n};\n","export const getRadioChecked = (\n  radioValue: string | undefined = \"on\",\n  newValue: unknown\n) => {\n  if (typeof newValue === \"string\") return newValue === radioValue;\n  return undefined;\n};\n\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest;\n  it(\"getRadioChecked\", () => {\n    expect(getRadioChecked(\"on\", \"on\")).toBe(true);\n    expect(getRadioChecked(\"on\", undefined)).toBe(undefined);\n    expect(getRadioChecked(\"trueValue\", undefined)).toBe(undefined);\n    expect(getRadioChecked(\"trueValue\", \"bob\")).toBe(false);\n    expect(getRadioChecked(\"trueValue\", \"trueValue\")).toBe(true);\n  });\n}\n","import { useActionData, useMatches, useNavigation } from \"@remix-run/react\";\nimport { useCallback, useContext } from \"react\";\nimport { getPath } from \"set-get\";\nimport invariant from \"tiny-invariant\";\nimport { FieldErrors, ValidationErrorResponseData } from \"..\";\nimport { formDefaultValuesKey } from \"./constants\";\nimport { InternalFormContext, InternalFormContextValue } from \"./formContext\";\nimport { Hydratable, hydratable } from \"./hydratable\";\nimport { useFormStore } from \"./state/storeHooks\";\nimport { InternalFormId } from \"./state/types\";\n\nexport const useInternalFormContext = (\n  formId?: string | symbol,\n  hookName?: string\n) => {\n  const formContext = useContext(InternalFormContext);\n\n  if (formId) return { formId };\n  if (formContext) return formContext;\n\n  throw new Error(\n    `Unable to determine form for ${hookName}. Please use it inside a ValidatedForm or pass a 'formId'.`\n  );\n};\n\nexport function useErrorResponseForForm({\n  fetcher,\n  subaction,\n  formId,\n}: InternalFormContextValue): ValidationErrorResponseData | null {\n  const actionData = useActionData<any>();\n  if (fetcher) {\n    if ((fetcher.data as any)?.fieldErrors) return fetcher.data as any;\n    return null;\n  }\n\n  if (!actionData?.fieldErrors) return null;\n\n  // If there's an explicit id, we should ignore data that has the wrong id\n  if (typeof formId === \"string\" && actionData.formId)\n    return actionData.formId === formId ? actionData : null;\n\n  if (\n    (!subaction && !actionData.subaction) ||\n    actionData.subaction === subaction\n  )\n    return actionData;\n\n  return null;\n}\n\nexport const useFieldErrorsForForm = (\n  context: InternalFormContextValue\n): Hydratable<FieldErrors | undefined> => {\n  const response = useErrorResponseForForm(context);\n  const hydrated = useFormStore(context.formId, (state) => state.isHydrated);\n  return hydratable.from(response?.fieldErrors, hydrated);\n};\n\nexport const useDefaultValuesFromLoader = ({\n  formId,\n}: InternalFormContextValue) => {\n  const matches = useMatches();\n  if (typeof formId === \"string\") {\n    const dataKey = formDefaultValuesKey(formId);\n    // If multiple loaders declare the same default values,\n    // we should use the data from the deepest route.\n    const match = matches\n      .reverse()\n      .find(\n        (match) =>\n          match.data && typeof match.data === \"object\" && dataKey in match.data\n      );\n    return (match as any)?.data[dataKey];\n  }\n\n  return null;\n};\n\nexport const useDefaultValuesForForm = (\n  context: InternalFormContextValue\n): Hydratable<{ [fieldName: string]: any }> => {\n  const { formId, defaultValuesProp } = context;\n  const hydrated = useFormStore(formId, (state) => state.isHydrated);\n  const errorResponse = useErrorResponseForForm(context);\n  const defaultValuesFromLoader = useDefaultValuesFromLoader(context);\n\n  // Typical flow is:\n  // - Default values only available from props or server\n  //   - Props have a higher priority than server\n  // - State gets hydrated with default values\n  // - After submit, we may need to use values from the error\n\n  if (hydrated) return hydratable.hydratedData();\n  if (errorResponse?.repopulateFields) {\n    invariant(\n      typeof errorResponse.repopulateFields === \"object\",\n      \"repopulateFields returned something other than an object\"\n    );\n    return hydratable.serverData(errorResponse.repopulateFields);\n  }\n  if (defaultValuesProp) return hydratable.serverData(defaultValuesProp);\n\n  return hydratable.serverData(defaultValuesFromLoader);\n};\n\nexport const useHasActiveFormSubmit = ({\n  fetcher,\n}: InternalFormContextValue): boolean => {\n  let navigation = useNavigation();\n  const hasActiveSubmission = fetcher\n    ? fetcher.state === \"submitting\"\n    : navigation.state === \"submitting\" || navigation.state === \"loading\";\n  return hasActiveSubmission;\n};\n\nexport const useFieldTouched = (\n  field: string,\n  { formId }: InternalFormContextValue\n) => {\n  const touched = useFormStore(formId, (state) => state.touchedFields[field]);\n  const setFieldTouched = useFormStore(formId, (state) => state.setTouched);\n  const setTouched = useCallback(\n    (touched: boolean) => setFieldTouched(field, touched),\n    [field, setFieldTouched]\n  );\n  return [touched, setTouched] as const;\n};\n\nexport const useFieldError = (\n  name: string,\n  context: InternalFormContextValue\n) => {\n  const fieldErrors = useFieldErrorsForForm(context);\n  const state = useFormStore(\n    context.formId,\n    (state) => state.fieldErrors[name]\n  );\n  return fieldErrors.map((fieldErrors) => fieldErrors?.[name]).hydrateTo(state);\n};\n\nexport const useClearError = (context: InternalFormContextValue) => {\n  const { formId } = context;\n  return useFormStore(formId, (state) => state.clearFieldError);\n};\n\nexport const useCurrentDefaultValueForField = (\n  formId: InternalFormId,\n  field: string\n) =>\n  useFormStore(formId, (state) => getPath(state.currentDefaultValues, field));\n\nexport const useFieldDefaultValue = (\n  name: string,\n  context: InternalFormContextValue\n) => {\n  const defaultValues = useDefaultValuesForForm(context);\n  const state = useCurrentDefaultValueForField(context.formId, name);\n\n  return defaultValues.map((val) => getPath(val, name)).hydrateTo(state);\n};\n\nexport const useInternalIsSubmitting = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.isSubmitting);\n\nexport const useInternalIsValid = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.isValid());\n\nexport const useInternalHasBeenSubmitted = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.hasBeenSubmitted);\n\nexport const useSmartValidate = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.smartValidate);\n\nexport const useValidate = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.validate);\n\nconst noOpReceiver = () => () => {};\nexport const useRegisterReceiveFocus = (formId: InternalFormId) =>\n  useFormStore(\n    formId,\n    (state) => state.formProps?.registerReceiveFocus ?? noOpReceiver\n  );\n\nconst defaultDefaultValues = {};\nexport const useSyncedDefaultValues = (formId: InternalFormId) =>\n  useFormStore(\n    formId,\n    (state) => state.formProps?.defaultValues ?? defaultDefaultValues\n  );\n\nexport const useSetTouched = ({ formId }: InternalFormContextValue) =>\n  useFormStore(formId, (state) => state.setTouched);\n\nexport const useTouchedFields = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.touchedFields);\n\nexport const useFieldErrors = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.fieldErrors);\n\nexport const useSetFieldErrors = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.setFieldErrors);\n\nexport const useResetFormElement = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.resetFormElement);\n\nexport const useSubmitForm = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.submit);\n\nexport const useFormActionProp = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.formProps?.action);\n\nexport const useFormSubactionProp = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.formProps?.subaction);\n\nexport const useFormValues = (formId: InternalFormId) =>\n  useFormStore(formId, (state) => state.getValues);\n","export const stringToPathArray = <T extends string>(\n  path: T\n): (string | number)[] => {\n  if (path.length === 0) return [];\n\n  const match =\n    path.match(/^\\[(.+?)\\](.*)$/) || path.match(/^\\.?([^\\.\\[\\]]+)(.*)$/);\n  if (match) {\n    const [_, key, rest] = match;\n    return [/^\\d+$/.test(key) ? Number(key) : key, ...stringToPathArray(rest)];\n  }\n  return [path];\n};\n","import { stringToPathArray } from \"./stringToPathArray\";\n\nexport function setPath<T>(object: T, path: string, defaultValue: any) {\n  return _setPathNormalized(object, stringToPathArray(path), defaultValue);\n}\n\nfunction _setPathNormalized(\n  object: any,\n  path: (string | number)[],\n  value: any\n): any {\n  const leadingSegments = path.slice(0, -1);\n  const lastSegment = path[path.length - 1];\n\n  let obj = object;\n  for (let i = 0; i < leadingSegments.length; i++) {\n    const segment = leadingSegments[i];\n    if (obj[segment] === undefined) {\n      const nextSegment = leadingSegments[i + 1] ?? lastSegment;\n      obj[segment] = typeof nextSegment === \"number\" ? [] : {};\n    }\n    obj = obj[segment];\n  }\n  obj[lastSegment] = value;\n  return object;\n}\n","import get from \"lodash.get\";\n\nexport const getPath = (object: any, path: string) => {\n  return get(object, path);\n};\n","export const FORM_ID_FIELD = \"__rvfInternalFormId\" as const;\nexport const FORM_DEFAULTS_FIELD = \"__rvfInternalFormDefaults\" as const;\nexport const formDefaultValuesKey = (formId: string) =>\n  `${FORM_DEFAULTS_FIELD}_${formId}`;\n","import { FetcherWithComponents } from \"@remix-run/react\";\nimport { createContext } from \"react\";\n\nexport type InternalFormContextValue = {\n  formId: string | symbol;\n  action?: string;\n  subaction?: string;\n  defaultValuesProp?: { [fieldName: string]: any };\n  fetcher?: FetcherWithComponents<unknown>;\n};\n\nexport const InternalFormContext =\n  createContext<InternalFormContextValue | null>(null);\n","/**\n * The purpose of this type is to simplify the logic\n * around data that needs to come from the server initially,\n * but from the internal state after hydration.\n */\nexport type Hydratable<T> = {\n  hydrateTo: (data: T) => T;\n  map: <U>(fn: (data: T) => U) => Hydratable<U>;\n};\n\nconst serverData = <T>(data: T): Hydratable<T> => ({\n  hydrateTo: () => data,\n  map: (fn) => serverData(fn(data)),\n});\n\nconst hydratedData = <T>(): Hydratable<T> => ({\n  hydrateTo: (hydratedData: T) => hydratedData,\n  map: <U>() => hydratedData<U>(),\n});\n\nconst from = <T>(data: T, hydrated: boolean): Hydratable<T> =>\n  hydrated ? hydratedData<T>() : serverData<T>(data);\n\nexport const hydratable = {\n  serverData,\n  hydratedData,\n  from,\n};\n","import { WritableDraft } from \"immer/dist/internal\";\nimport { getPath, setPath } from \"set-get\";\nimport invariant from \"tiny-invariant\";\nimport { create, GetState } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\nimport {\n  FieldErrors,\n  TouchedFields,\n  ValidationResult,\n  Validator,\n} from \"../../validation/types\";\nimport { requestSubmit } from \"../logic/requestSubmit\";\nimport * as arrayUtil from \"./arrayUtil\";\nimport { InternalFormId } from \"./types\";\n\nexport type SyncedFormProps = {\n  formId?: string;\n  action?: string;\n  subaction?: string;\n  defaultValues: { [fieldName: string]: any };\n  registerReceiveFocus: (fieldName: string, handler: () => void) => () => void;\n  validator: Validator<unknown>;\n};\n\nexport type SmartValidateOpts = {\n  alwaysIncludeErrorsFromFields?: string[];\n};\n\nexport type FormStoreState = {\n  forms: { [formId: InternalFormId]: FormState };\n  form: (formId: InternalFormId) => FormState;\n  registerForm: (formId: InternalFormId) => void;\n  cleanupForm: (formId: InternalFormId) => void;\n};\n\nexport type FormState = {\n  isHydrated: boolean;\n  isSubmitting: boolean;\n  hasBeenSubmitted: boolean;\n  fieldErrors: FieldErrors;\n  touchedFields: TouchedFields;\n  formProps?: SyncedFormProps;\n  formElement: HTMLFormElement | null;\n  currentDefaultValues: Record<string, any>;\n\n  isValid: () => boolean;\n  startSubmit: () => void;\n  endSubmit: () => void;\n  setTouched: (field: string, touched: boolean) => void;\n  setFieldError: (field: string, error: string) => void;\n  setFieldErrors: (errors: FieldErrors) => void;\n  clearFieldError: (field: string) => void;\n  reset: () => void;\n  syncFormProps: (props: SyncedFormProps) => void;\n  setFormElement: (formElement: HTMLFormElement | null) => void;\n  validate: () => Promise<ValidationResult<unknown>>;\n  smartValidate: (\n    opts?: SmartValidateOpts\n  ) => Promise<ValidationResult<unknown>>;\n  resetFormElement: () => void;\n  submit: () => void;\n  getValues: () => FormData;\n\n  controlledFields: {\n    values: { [fieldName: string]: any };\n    refCounts: { [fieldName: string]: number };\n    valueUpdatePromises: { [fieldName: string]: Promise<void> };\n    valueUpdateResolvers: { [fieldName: string]: () => void };\n\n    register: (fieldName: string) => void;\n    unregister: (fieldName: string) => void;\n    setValue: (fieldName: string, value: unknown) => void;\n    kickoffValueUpdate: (fieldName: string) => void;\n    getValue: (fieldName: string) => unknown;\n    awaitValueUpdate: (fieldName: string) => Promise<void>;\n\n    array: {\n      push: (fieldName: string, value: unknown) => void;\n      swap: (fieldName: string, indexA: number, indexB: number) => void;\n      move: (fieldName: string, fromIndex: number, toIndex: number) => void;\n      insert: (fieldName: string, index: number, value: unknown) => void;\n      unshift: (fieldName: string, value: unknown) => void;\n      remove: (fieldName: string, index: number) => void;\n      pop: (fieldName: string) => void;\n      replace: (fieldName: string, index: number, value: unknown) => void;\n    };\n  };\n};\n\nconst noOp = () => {};\nconst defaultFormState: FormState = {\n  isHydrated: false,\n  isSubmitting: false,\n  hasBeenSubmitted: false,\n  touchedFields: {},\n  fieldErrors: {},\n  formElement: null,\n  isValid: () => true,\n  startSubmit: noOp,\n  endSubmit: noOp,\n  setTouched: noOp,\n  setFieldError: noOp,\n  setFieldErrors: noOp,\n  clearFieldError: noOp,\n  currentDefaultValues: {},\n\n  reset: () => noOp,\n  syncFormProps: noOp,\n  setFormElement: noOp,\n\n  validate: async () => {\n    throw new Error(\"Validate called before form was initialized.\");\n  },\n\n  smartValidate: async () => {\n    throw new Error(\"Validate called before form was initialized.\");\n  },\n\n  submit: async () => {\n    throw new Error(\"Submit called before form was initialized.\");\n  },\n\n  resetFormElement: noOp,\n  getValues: () => new FormData(),\n\n  controlledFields: {\n    values: {},\n    refCounts: {},\n    valueUpdatePromises: {},\n    valueUpdateResolvers: {},\n\n    register: noOp,\n    unregister: noOp,\n    setValue: noOp,\n    getValue: noOp,\n    kickoffValueUpdate: noOp,\n    awaitValueUpdate: async () => {\n      throw new Error(\"AwaitValueUpdate called before form was initialized.\");\n    },\n\n    array: {\n      push: noOp,\n      swap: noOp,\n      move: noOp,\n      insert: noOp,\n      unshift: noOp,\n      remove: noOp,\n      pop: noOp,\n      replace: noOp,\n    },\n  },\n};\n\nconst createFormState = (\n  set: (setter: (draft: WritableDraft<FormState>) => void) => void,\n  get: GetState<FormState>\n): FormState => ({\n  // It's not \"hydrated\" until the form props are synced\n  isHydrated: false,\n  isSubmitting: false,\n  hasBeenSubmitted: false,\n  touchedFields: {},\n  fieldErrors: {},\n  formElement: null,\n  currentDefaultValues: {},\n\n  isValid: () => Object.keys(get().fieldErrors).length === 0,\n  startSubmit: () =>\n    set((state) => {\n      state.isSubmitting = true;\n      state.hasBeenSubmitted = true;\n    }),\n  endSubmit: () =>\n    set((state) => {\n      state.isSubmitting = false;\n    }),\n  setTouched: (fieldName, touched) =>\n    set((state) => {\n      state.touchedFields[fieldName] = touched;\n    }),\n  setFieldError: (fieldName: string, error: string) =>\n    set((state) => {\n      state.fieldErrors[fieldName] = error;\n    }),\n  setFieldErrors: (errors: FieldErrors) =>\n    set((state) => {\n      state.fieldErrors = errors;\n    }),\n  clearFieldError: (fieldName: string) =>\n    set((state) => {\n      delete state.fieldErrors[fieldName];\n    }),\n  reset: () =>\n    set((state) => {\n      state.fieldErrors = {};\n      state.touchedFields = {};\n      state.hasBeenSubmitted = false;\n      const nextDefaults = state.formProps?.defaultValues ?? {};\n      state.controlledFields.values = nextDefaults;\n      state.currentDefaultValues = nextDefaults;\n    }),\n  syncFormProps: (props: SyncedFormProps) =>\n    set((state) => {\n      if (!state.isHydrated) {\n        state.controlledFields.values = props.defaultValues;\n        state.currentDefaultValues = props.defaultValues;\n      }\n\n      state.formProps = props;\n      state.isHydrated = true;\n    }),\n  setFormElement: (formElement: HTMLFormElement | null) => {\n    // This gets called frequently, so we want to avoid calling set() every time\n    // Or else we wind up with an infinite loop\n    if (get().formElement === formElement) return;\n    set((state) => {\n      // weird type issue here\n      // seems to be because formElement is a writable draft\n      state.formElement = formElement as any;\n    });\n  },\n  validate: async () => {\n    const formElement = get().formElement;\n    invariant(\n      formElement,\n      \"Cannot find reference to form. This is probably a bug in remix-validated-form.\"\n    );\n\n    const validator = get().formProps?.validator;\n    invariant(\n      validator,\n      \"Cannot find validator. This is probably a bug in remix-validated-form.\"\n    );\n\n    const result = await validator.validate(new FormData(formElement));\n    if (result.error) get().setFieldErrors(result.error.fieldErrors);\n    return result;\n  },\n\n  smartValidate: async ({ alwaysIncludeErrorsFromFields = [] } = {}) => {\n    const formElement = get().formElement;\n    invariant(\n      formElement,\n      \"Cannot find reference to form. This is probably a bug in remix-validated-form.\"\n    );\n\n    const validator = get().formProps?.validator;\n    invariant(\n      validator,\n      \"Cannot find validator. This is probably a bug in remix-validated-form.\"\n    );\n\n    await Promise.all(\n      alwaysIncludeErrorsFromFields.map((field) =>\n        get().controlledFields.awaitValueUpdate?.(field)\n      )\n    );\n\n    const validationResult = await validator.validate(\n      new FormData(formElement)\n    );\n    if (!validationResult.error) {\n      // Only update the field errors if it hasn't changed\n      const hadErrors = Object.keys(get().fieldErrors).length > 0;\n      if (hadErrors) get().setFieldErrors({});\n      return validationResult;\n    }\n\n    const {\n      error: { fieldErrors },\n    } = validationResult;\n    const errorFields = new Set<string>();\n    const incomingErrors = new Set<string>();\n    const prevErrors = new Set<string>();\n\n    Object.keys(fieldErrors).forEach((field) => {\n      errorFields.add(field);\n      incomingErrors.add(field);\n    });\n\n    Object.keys(get().fieldErrors).forEach((field) => {\n      errorFields.add(field);\n      prevErrors.add(field);\n    });\n\n    const fieldsToUpdate = new Set<string>();\n    const fieldsToDelete = new Set<string>();\n\n    errorFields.forEach((field) => {\n      // If an error has been cleared, remove it.\n      if (!incomingErrors.has(field)) {\n        fieldsToDelete.add(field);\n        return;\n      }\n\n      // If an error has changed, we should update it.\n      if (prevErrors.has(field) && incomingErrors.has(field)) {\n        // Only update if the error has changed to avoid unnecessary rerenders\n        if (fieldErrors[field] !== get().fieldErrors[field])\n          fieldsToUpdate.add(field);\n        return;\n      }\n\n      // If the error is always included, then we should update it.\n      if (alwaysIncludeErrorsFromFields.includes(field)) {\n        fieldsToUpdate.add(field);\n        return;\n      }\n\n      // If the error is new, then only update if the field has been touched\n      // or if the form has been submitted\n      if (!prevErrors.has(field)) {\n        const fieldTouched = get().touchedFields[field];\n        const formHasBeenSubmitted = get().hasBeenSubmitted;\n        if (fieldTouched || formHasBeenSubmitted) fieldsToUpdate.add(field);\n        return;\n      }\n    });\n\n    if (fieldsToDelete.size === 0 && fieldsToUpdate.size === 0) {\n      return { ...validationResult, error: { fieldErrors: get().fieldErrors } };\n    }\n\n    set((state) => {\n      fieldsToDelete.forEach((field) => {\n        delete state.fieldErrors[field];\n      });\n\n      fieldsToUpdate.forEach((field) => {\n        state.fieldErrors[field] = fieldErrors[field];\n      });\n    });\n\n    return { ...validationResult, error: { fieldErrors: get().fieldErrors } };\n  },\n\n  submit: () => {\n    const formElement = get().formElement;\n    invariant(\n      formElement,\n      \"Cannot find reference to form. This is probably a bug in remix-validated-form.\"\n    );\n\n    requestSubmit(formElement);\n  },\n\n  getValues: () => new FormData(get().formElement ?? undefined),\n\n  resetFormElement: () => get().formElement?.reset(),\n\n  controlledFields: {\n    values: {},\n    refCounts: {},\n    valueUpdatePromises: {},\n    valueUpdateResolvers: {},\n\n    register: (fieldName) => {\n      set((state) => {\n        const current = state.controlledFields.refCounts[fieldName] ?? 0;\n        state.controlledFields.refCounts[fieldName] = current + 1;\n      });\n    },\n    unregister: (fieldName) => {\n      // For this helper in particular, we may run into a case where state is undefined.\n      // When the whole form unmounts, the form state may be cleaned up before the fields are.\n      if (get() === null || get() === undefined) return;\n      set((state) => {\n        const current = state.controlledFields.refCounts[fieldName] ?? 0;\n        if (current > 1) {\n          state.controlledFields.refCounts[fieldName] = current - 1;\n          return;\n        }\n\n        const isNested = Object.keys(state.controlledFields.refCounts).some(\n          (key) => fieldName.startsWith(key) && key !== fieldName\n        );\n\n        // When nested within a field array, we should leave resetting up to the field array\n        if (!isNested) {\n          setPath(\n            state.controlledFields.values,\n            fieldName,\n            getPath(state.formProps?.defaultValues, fieldName)\n          );\n          setPath(\n            state.currentDefaultValues,\n            fieldName,\n            getPath(state.formProps?.defaultValues, fieldName)\n          );\n        }\n\n        delete state.controlledFields.refCounts[fieldName];\n      });\n    },\n    getValue: (fieldName) => getPath(get().controlledFields.values, fieldName),\n    setValue: (fieldName, value) => {\n      set((state) => {\n        setPath(state.controlledFields.values, fieldName, value);\n      });\n      get().controlledFields.kickoffValueUpdate(fieldName);\n    },\n    kickoffValueUpdate: (fieldName) => {\n      const clear = () =>\n        set((state) => {\n          delete state.controlledFields.valueUpdateResolvers[fieldName];\n          delete state.controlledFields.valueUpdatePromises[fieldName];\n        });\n      set((state) => {\n        const promise = new Promise<void>((resolve) => {\n          state.controlledFields.valueUpdateResolvers[fieldName] = resolve;\n        }).then(clear);\n        state.controlledFields.valueUpdatePromises[fieldName] = promise;\n      });\n    },\n\n    awaitValueUpdate: async (fieldName) => {\n      await get().controlledFields.valueUpdatePromises[fieldName];\n    },\n\n    array: {\n      push: (fieldName, item) => {\n        set((state) => {\n          arrayUtil\n            .getArray(state.controlledFields.values, fieldName)\n            .push(item);\n          arrayUtil.getArray(state.currentDefaultValues, fieldName).push(item);\n          // New item added to the end, no need to update touched or error\n        });\n        get().controlledFields.kickoffValueUpdate(fieldName);\n      },\n\n      swap: (fieldName, indexA, indexB) => {\n        set((state) => {\n          arrayUtil.swap(\n            arrayUtil.getArray(state.controlledFields.values, fieldName),\n            indexA,\n            indexB\n          );\n          arrayUtil.swap(\n            arrayUtil.getArray(state.currentDefaultValues, fieldName),\n            indexA,\n            indexB\n          );\n          arrayUtil.mutateAsArray(fieldName, state.touchedFields, (array) =>\n            arrayUtil.swap(array, indexA, indexB)\n          );\n          arrayUtil.mutateAsArray(fieldName, state.fieldErrors, (array) =>\n            arrayUtil.swap(array, indexA, indexB)\n          );\n        });\n        get().controlledFields.kickoffValueUpdate(fieldName);\n      },\n\n      move: (fieldName, from, to) => {\n        set((state) => {\n          arrayUtil.move(\n            arrayUtil.getArray(state.controlledFields.values, fieldName),\n            from,\n            to\n          );\n          arrayUtil.move(\n            arrayUtil.getArray(state.currentDefaultValues, fieldName),\n            from,\n            to\n          );\n          arrayUtil.mutateAsArray(fieldName, state.touchedFields, (array) =>\n            arrayUtil.move(array, from, to)\n          );\n          arrayUtil.mutateAsArray(fieldName, state.fieldErrors, (array) =>\n            arrayUtil.move(array, from, to)\n          );\n        });\n        get().controlledFields.kickoffValueUpdate(fieldName);\n      },\n      insert: (fieldName, index, item) => {\n        set((state) => {\n          arrayUtil.insert(\n            arrayUtil.getArray(state.controlledFields.values, fieldName),\n            index,\n            item\n          );\n          arrayUtil.insert(\n            arrayUtil.getArray(state.currentDefaultValues, fieldName),\n            index,\n            item\n          );\n          // Even though this is a new item, we need to push around other items.\n          arrayUtil.mutateAsArray(fieldName, state.touchedFields, (array) =>\n            arrayUtil.insertEmpty(array, index)\n          );\n          arrayUtil.mutateAsArray(fieldName, state.fieldErrors, (array) =>\n            arrayUtil.insertEmpty(array, index)\n          );\n        });\n        get().controlledFields.kickoffValueUpdate(fieldName);\n      },\n      remove: (fieldName, index) => {\n        set((state) => {\n          arrayUtil.remove(\n            arrayUtil.getArray(state.controlledFields.values, fieldName),\n            index\n          );\n          arrayUtil.remove(\n            arrayUtil.getArray(state.currentDefaultValues, fieldName),\n            index\n          );\n          arrayUtil.mutateAsArray(fieldName, state.touchedFields, (array) =>\n            arrayUtil.remove(array, index)\n          );\n          arrayUtil.mutateAsArray(fieldName, state.fieldErrors, (array) =>\n            arrayUtil.remove(array, index)\n          );\n        });\n        get().controlledFields.kickoffValueUpdate(fieldName);\n      },\n      pop: (fieldName) => {\n        set((state) => {\n          arrayUtil.getArray(state.controlledFields.values, fieldName).pop();\n          arrayUtil.getArray(state.currentDefaultValues, fieldName).pop();\n          arrayUtil.mutateAsArray(fieldName, state.touchedFields, (array) =>\n            array.pop()\n          );\n          arrayUtil.mutateAsArray(fieldName, state.fieldErrors, (array) =>\n            array.pop()\n          );\n        });\n        get().controlledFields.kickoffValueUpdate(fieldName);\n      },\n      unshift: (fieldName, value) => {\n        set((state) => {\n          arrayUtil\n            .getArray(state.controlledFields.values, fieldName)\n            .unshift(value);\n          arrayUtil\n            .getArray(state.currentDefaultValues, fieldName)\n            .unshift(value);\n          arrayUtil.mutateAsArray(fieldName, state.touchedFields, (array) =>\n            arrayUtil.insertEmpty(array, 0)\n          );\n          arrayUtil.mutateAsArray(fieldName, state.fieldErrors, (array) =>\n            arrayUtil.insertEmpty(array, 0)\n          );\n        });\n      },\n      replace: (fieldName, index, item) => {\n        set((state) => {\n          arrayUtil.replace(\n            arrayUtil.getArray(state.controlledFields.values, fieldName),\n            index,\n            item\n          );\n          arrayUtil.replace(\n            arrayUtil.getArray(state.currentDefaultValues, fieldName),\n            index,\n            item\n          );\n          arrayUtil.mutateAsArray(fieldName, state.touchedFields, (array) =>\n            arrayUtil.replace(array, index, item)\n          );\n          arrayUtil.mutateAsArray(fieldName, state.fieldErrors, (array) =>\n            arrayUtil.replace(array, index, item)\n          );\n        });\n        get().controlledFields.kickoffValueUpdate(fieldName);\n      },\n    },\n  },\n});\n\nexport const useRootFormStore = create<FormStoreState>()(\n  immer((set, get) => ({\n    forms: {},\n    form: (formId) => {\n      return get().forms[formId] ?? defaultFormState;\n    },\n    cleanupForm: (formId: InternalFormId) => {\n      set((state) => {\n        delete state.forms[formId];\n      });\n    },\n    registerForm: (formId: InternalFormId) => {\n      if (get().forms[formId]) return;\n      set((state) => {\n        state.forms[formId] = createFormState(\n          (setter) => set((state) => setter(state.forms[formId])),\n          () => get().forms[formId]\n        ) as WritableDraft<FormState>;\n      });\n    },\n  }))\n);\n","/**\n * Ponyfill of the HTMLFormElement.requestSubmit() method.\n * Based on polyfill from: https://github.com/javan/form-request-submit-polyfill/blob/main/form-request-submit-polyfill.js\n */\nexport const requestSubmit = (\n  element: HTMLFormElement,\n  submitter?: HTMLElement\n) => {\n  // In vitest, let's test the polyfill.\n  // Cypress will test the native implementation by nature of using chrome.\n  if (\n    typeof Object.getPrototypeOf(element).requestSubmit === \"function\" &&\n    !import.meta.vitest\n  ) {\n    element.requestSubmit(submitter);\n    return;\n  }\n\n  if (submitter) {\n    validateSubmitter(element, submitter);\n    submitter.click();\n    return;\n  }\n\n  const dummySubmitter = document.createElement(\"input\");\n  dummySubmitter.type = \"submit\";\n  dummySubmitter.hidden = true;\n  element.appendChild(dummySubmitter);\n  dummySubmitter.click();\n  element.removeChild(dummySubmitter);\n};\n\nfunction validateSubmitter(element: HTMLFormElement, submitter: HTMLElement) {\n  // Should be redundant, but here for completeness\n  const isHtmlElement = submitter instanceof HTMLElement;\n  if (!isHtmlElement) {\n    raise(TypeError, \"parameter 1 is not of type 'HTMLElement'\");\n  }\n\n  const hasSubmitType =\n    \"type\" in submitter && (submitter as HTMLInputElement).type === \"submit\";\n  if (!hasSubmitType)\n    raise(TypeError, \"The specified element is not a submit button\");\n\n  const isForCorrectForm =\n    \"form\" in submitter && (submitter as HTMLInputElement).form === element;\n  if (!isForCorrectForm)\n    raise(\n      DOMException,\n      \"The specified element is not owned by this form element\",\n      \"NotFoundError\"\n    );\n}\n\ninterface ErrorConstructor {\n  new (message: string, name?: string): Error;\n}\n\nfunction raise(\n  errorConstructor: ErrorConstructor,\n  message: string,\n  name?: string\n): never {\n  throw new errorConstructor(\n    \"Failed to execute 'requestSubmit' on 'HTMLFormElement': \" + message + \".\",\n    name\n  );\n}\n\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest;\n  it(\"should validate the submitter\", () => {\n    const form = document.createElement(\"form\");\n    document.body.appendChild(form);\n\n    const submitter = document.createElement(\"input\");\n    expect(() => validateSubmitter(null as any, null as any)).toThrow();\n    expect(() => validateSubmitter(form, null as any)).toThrow();\n    expect(() => validateSubmitter(form, submitter)).toThrow();\n    expect(() =>\n      validateSubmitter(form, document.createElement(\"div\"))\n    ).toThrow();\n\n    submitter.type = \"submit\";\n    expect(() => validateSubmitter(form, submitter)).toThrow();\n\n    form.appendChild(submitter);\n    expect(() => validateSubmitter(form, submitter)).not.toThrow();\n\n    form.removeChild(submitter);\n    expect(() => validateSubmitter(form, submitter)).toThrow();\n\n    document.body.appendChild(submitter);\n    form.id = \"test-form\";\n    submitter.setAttribute(\"form\", \"test-form\");\n    expect(() => validateSubmitter(form, submitter)).not.toThrow();\n\n    const button = document.createElement(\"button\");\n    button.type = \"submit\";\n    form.appendChild(button);\n    expect(() => validateSubmitter(form, button)).not.toThrow();\n  });\n}\n","import { getPath, setPath } from \"set-get\";\nimport invariant from \"tiny-invariant\";\n\n////\n// All of these array helpers are written in a way that mutates the original array.\n// This is because we're working with immer.\n////\n\nexport const getArray = (values: any, field: string): unknown[] => {\n  const value = getPath(values, field);\n  if (value === undefined || value === null) {\n    const newValue: unknown[] = [];\n    setPath(values, field, newValue);\n    return newValue;\n  }\n  invariant(\n    Array.isArray(value),\n    `FieldArray: defaultValue value for ${field} must be an array, null, or undefined`\n  );\n  return value;\n};\n\nexport const sparseCopy = <T>(array: T[]): T[] => array.slice();\n\nexport const swap = (array: unknown[], indexA: number, indexB: number) => {\n  const itemA = array[indexA];\n  const itemB = array[indexB];\n\n  const hasItemA = indexA in array;\n  const hasItemB = indexB in array;\n\n  // If we're dealing with a sparse array (i.e. one of the indeces doesn't exist),\n  // we should keep it sparse\n  if (hasItemA) {\n    array[indexB] = itemA;\n  } else {\n    delete array[indexB];\n  }\n\n  if (hasItemB) {\n    array[indexA] = itemB;\n  } else {\n    delete array[indexA];\n  }\n};\n\n// A splice that can handle sparse arrays\nfunction sparseSplice(\n  array: unknown[],\n  start: number,\n  deleteCount?: number,\n  item?: unknown\n) {\n  // Inserting an item into an array won't behave as we need it to if the array isn't\n  // at least as long as the start index. We can force the array to be long enough like this.\n  if (array.length < start && item) {\n    array.length = start;\n  }\n\n  // If we just pass item in, it'll be undefined and splice will delete the item.\n  if (arguments.length === 4) return array.splice(start, deleteCount!, item);\n  else if (arguments.length === 3) return array.splice(start, deleteCount);\n  return array.splice(start);\n}\n\nexport const move = (array: unknown[], from: number, to: number) => {\n  const [item] = sparseSplice(array, from, 1);\n  sparseSplice(array, to, 0, item);\n};\n\nexport const insert = (array: unknown[], index: number, value: unknown) => {\n  sparseSplice(array, index, 0, value);\n};\n\nexport const insertEmpty = (array: unknown[], index: number) => {\n  const tail = sparseSplice(array, index);\n  tail.forEach((item, i) => {\n    sparseSplice(array, index + i + 1, 0, item);\n  });\n};\n\nexport const remove = (array: unknown[], index: number) => {\n  sparseSplice(array, index, 1);\n};\n\nexport const replace = (array: unknown[], index: number, value: unknown) => {\n  sparseSplice(array, index, 1, value);\n};\n\n/**\n * The purpose of this helper is to make it easier to update `fieldErrors` and `touchedFields`.\n * We key those objects by full paths to the fields.\n * When we're doing array mutations, that makes it difficult to update those objects.\n */\nexport const mutateAsArray = (\n  field: string,\n  obj: Record<string, any>,\n  mutate: (arr: any[]) => void\n) => {\n  const beforeKeys = new Set<string>();\n  const arr: any[] = [];\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (key.startsWith(field) && key !== field) {\n      beforeKeys.add(key);\n      setPath(arr, key.substring(field.length), value);\n    }\n  }\n\n  mutate(arr);\n  for (const key of beforeKeys) {\n    delete obj[key];\n  }\n\n  const newKeys = getDeepArrayPaths(arr);\n  for (const key of newKeys) {\n    const val = getPath(arr, key);\n    if (val !== undefined) {\n      obj[`${field}${key}`] = val;\n    }\n  }\n};\n\nconst getDeepArrayPaths = (obj: any, basePath: string = \"\"): string[] => {\n  // This only needs to handle arrays and plain objects\n  // and we can assume the first call is always an array.\n\n  if (Array.isArray(obj)) {\n    return obj.flatMap((item, index) =>\n      getDeepArrayPaths(item, `${basePath}[${index}]`)\n    );\n  }\n\n  if (typeof obj === \"object\") {\n    return Object.keys(obj).flatMap((key) =>\n      getDeepArrayPaths(obj[key], `${basePath}.${key}`)\n    );\n  }\n\n  return [basePath];\n};\n\nif (import.meta.vitest) {\n  const { describe, expect, it } = import.meta.vitest;\n\n  // Count the actual number of items in the array\n  // instead of just getting the length.\n  // This is useful for validating that sparse arrays are handled correctly.\n  const countArrayItems = (arr: any[]) => {\n    let count = 0;\n    arr.forEach(() => count++);\n    return count;\n  };\n\n  describe(\"getArray\", () => {\n    it(\"shoud get a deeply nested array that can be mutated to update the nested value\", () => {\n      const values = {\n        d: [\n          { foo: \"bar\", baz: [true, false] },\n          { e: true, f: \"hi\" },\n        ],\n      };\n      const result = getArray(values, \"d[0].baz\");\n      const finalValues = {\n        d: [\n          { foo: \"bar\", baz: [true, false, true] },\n          { e: true, f: \"hi\" },\n        ],\n      };\n\n      expect(result).toEqual([true, false]);\n      result.push(true);\n      expect(values).toEqual(finalValues);\n    });\n\n    it(\"should return an empty array that can be mutated if result is null or undefined\", () => {\n      const values = {};\n      const result = getArray(values, \"a.foo[0].bar\");\n      const finalValues = {\n        a: { foo: [{ bar: [\"Bob ross\"] }] },\n      };\n\n      expect(result).toEqual([]);\n      result.push(\"Bob ross\");\n      expect(values).toEqual(finalValues);\n    });\n\n    it(\"should throw if the value is defined and not an array\", () => {\n      const values = { foo: \"foo\" };\n      expect(() => getArray(values, \"foo\")).toThrow();\n    });\n  });\n\n  describe(\"swap\", () => {\n    it(\"should swap two items\", () => {\n      const array = [1, 2, 3];\n      swap(array, 0, 1);\n      expect(array).toEqual([2, 1, 3]);\n    });\n\n    it(\"should work for sparse arrays\", () => {\n      // A bit of a sanity check for native array behavior\n      const arr = [] as any[];\n      arr[0] = true;\n      swap(arr, 0, 2);\n\n      expect(countArrayItems(arr)).toEqual(1);\n      expect(0 in arr).toBe(false);\n      expect(2 in arr).toBe(true);\n      expect(arr[2]).toEqual(true);\n    });\n  });\n\n  describe(\"move\", () => {\n    it(\"should move an item to a new index\", () => {\n      const array = [1, 2, 3];\n      move(array, 0, 1);\n      expect(array).toEqual([2, 1, 3]);\n    });\n\n    it(\"should work with sparse arrays\", () => {\n      const array = [1];\n      move(array, 0, 2);\n\n      expect(countArrayItems(array)).toEqual(1);\n      expect(array).toEqual([undefined, undefined, 1]);\n    });\n  });\n\n  describe(\"insert\", () => {\n    it(\"should insert an item at a new index\", () => {\n      const array = [1, 2, 3];\n      insert(array, 1, 4);\n      expect(array).toEqual([1, 4, 2, 3]);\n    });\n\n    it(\"should be able to insert falsey values\", () => {\n      const array = [1, 2, 3];\n      insert(array, 1, null);\n      expect(array).toEqual([1, null, 2, 3]);\n    });\n\n    it(\"should handle sparse arrays\", () => {\n      const array: any[] = [];\n      array[2] = true;\n      insert(array, 0, true);\n\n      expect(countArrayItems(array)).toEqual(2);\n      expect(array).toEqual([true, undefined, undefined, true]);\n    });\n  });\n\n  describe(\"insertEmpty\", () => {\n    it(\"should insert an empty item at a given index\", () => {\n      const array = [1, 2, 3];\n      insertEmpty(array, 1);\n      // eslint-disable-next-line no-sparse-arrays\n      expect(array).toStrictEqual([1, , 2, 3]);\n      expect(array).not.toStrictEqual([1, undefined, 2, 3]);\n    });\n\n    it(\"should work with already sparse arrays\", () => {\n      // eslint-disable-next-line no-sparse-arrays\n      const array = [, , 1, , 2, , 3];\n      insertEmpty(array, 3);\n      // eslint-disable-next-line no-sparse-arrays\n      expect(array).toStrictEqual([, , 1, , , 2, , 3]);\n      expect(array).not.toStrictEqual([\n        undefined,\n        undefined,\n        1,\n        undefined,\n        undefined,\n        2,\n        undefined,\n        3,\n      ]);\n    });\n  });\n\n  describe(\"remove\", () => {\n    it(\"should remove an item at a given index\", () => {\n      const array = [1, 2, 3];\n      remove(array, 1);\n      expect(array).toEqual([1, 3]);\n    });\n\n    it(\"should handle sparse arrays\", () => {\n      const array: any[] = [];\n      array[2] = true;\n      remove(array, 0);\n\n      expect(countArrayItems(array)).toEqual(1);\n      expect(array).toEqual([undefined, true]);\n    });\n  });\n\n  describe(\"replace\", () => {\n    it(\"should replace an item at a given index\", () => {\n      const array = [1, 2, 3];\n      replace(array, 1, 4);\n      expect(array).toEqual([1, 4, 3]);\n    });\n\n    it(\"should handle sparse arrays\", () => {\n      const array: any[] = [];\n      array[2] = true;\n      replace(array, 0, true);\n      expect(countArrayItems(array)).toEqual(2);\n      expect(array).toEqual([true, undefined, true]);\n    });\n  });\n\n  describe(\"mutateAsArray\", () => {\n    it(\"should handle swap\", () => {\n      const values = {\n        myField: \"something\",\n        \"myField[0]\": \"foo\",\n        \"myField[2]\": \"bar\",\n        otherField: \"baz\",\n        \"otherField[0]\": \"something else\",\n      };\n      mutateAsArray(\"myField\", values, (arr) => {\n        swap(arr, 0, 2);\n      });\n      expect(values).toEqual({\n        myField: \"something\",\n        \"myField[0]\": \"bar\",\n        \"myField[2]\": \"foo\",\n        otherField: \"baz\",\n        \"otherField[0]\": \"something else\",\n      });\n    });\n\n    it(\"should swap sparse arrays\", () => {\n      const values = {\n        myField: \"something\",\n        \"myField[0]\": \"foo\",\n        otherField: \"baz\",\n        \"otherField[0]\": \"something else\",\n      };\n      mutateAsArray(\"myField\", values, (arr) => {\n        swap(arr, 0, 2);\n      });\n      expect(values).toEqual({\n        myField: \"something\",\n        \"myField[2]\": \"foo\",\n        otherField: \"baz\",\n        \"otherField[0]\": \"something else\",\n      });\n    });\n\n    it(\"should handle arrays with nested values\", () => {\n      const values = {\n        myField: \"something\",\n        \"myField[0].title\": \"foo\",\n        \"myField[0].note\": \"bar\",\n        \"myField[2].title\": \"other\",\n        \"myField[2].note\": \"other\",\n        otherField: \"baz\",\n        \"otherField[0]\": \"something else\",\n      };\n      mutateAsArray(\"myField\", values, (arr) => {\n        swap(arr, 0, 2);\n      });\n      expect(values).toEqual({\n        myField: \"something\",\n        \"myField[0].title\": \"other\",\n        \"myField[0].note\": \"other\",\n        \"myField[2].title\": \"foo\",\n        \"myField[2].note\": \"bar\",\n        otherField: \"baz\",\n        \"otherField[0]\": \"something else\",\n      });\n    });\n\n    it(\"should handle move\", () => {\n      const values = {\n        myField: \"something\",\n        \"myField[0]\": \"foo\",\n        \"myField[1]\": \"bar\",\n        \"myField[2]\": \"baz\",\n        \"otherField[0]\": \"something else\",\n      };\n      mutateAsArray(\"myField\", values, (arr) => {\n        move(arr, 0, 2);\n      });\n      expect(values).toEqual({\n        myField: \"something\",\n        \"myField[0]\": \"bar\",\n        \"myField[1]\": \"baz\",\n        \"myField[2]\": \"foo\",\n        \"otherField[0]\": \"something else\",\n      });\n    });\n\n    it(\"should not create keys for `undefined`\", () => {\n      const values = {\n        \"myField[0]\": \"foo\",\n      };\n      mutateAsArray(\"myField\", values, (arr) => {\n        arr.unshift(undefined);\n      });\n      expect(Object.keys(values)).toHaveLength(1);\n      expect(values).toEqual({\n        \"myField[1]\": \"foo\",\n      });\n    });\n\n    it(\"should handle remove\", () => {\n      const values = {\n        myField: \"something\",\n        \"myField[0]\": \"foo\",\n        \"myField[1]\": \"bar\",\n        \"myField[2]\": \"baz\",\n        \"otherField[0]\": \"something else\",\n      };\n      mutateAsArray(\"myField\", values, (arr) => {\n        remove(arr, 1);\n      });\n      expect(values).toEqual({\n        myField: \"something\",\n        \"myField[0]\": \"foo\",\n        \"myField[1]\": \"baz\",\n        \"otherField[0]\": \"something else\",\n      });\n      expect(\"myField[2]\" in values).toBe(false);\n    });\n  });\n\n  describe(\"getDeepArrayPaths\", () => {\n    it(\"should return all paths recursively\", () => {\n      const obj = [\n        true,\n        true,\n        [true, true],\n        { foo: true, bar: { baz: true, test: [true] } },\n      ];\n\n      expect(getDeepArrayPaths(obj, \"myField\")).toEqual([\n        \"myField[0]\",\n        \"myField[1]\",\n        \"myField[2][0]\",\n        \"myField[2][1]\",\n        \"myField[3].foo\",\n        \"myField[3].bar.baz\",\n        \"myField[3].bar.test[0]\",\n      ]);\n    });\n  });\n}\n","import { FormState, useRootFormStore } from \"./createFormStore\";\nimport { InternalFormId } from \"./types\";\n\nexport const useFormStore = <T>(\n  formId: InternalFormId,\n  selector: (state: FormState) => T\n) => {\n  return useRootFormStore((state) => selector(state.form(formId)));\n};\n","import { useCallback, useEffect } from \"react\";\nimport { InternalFormContextValue } from \"../formContext\";\nimport { useFieldDefaultValue } from \"../hooks\";\nimport { useFormStore } from \"./storeHooks\";\nimport { InternalFormId } from \"./types\";\n\nexport const useControlledFieldValue = (\n  context: InternalFormContextValue,\n  field: string\n) => {\n  const value = useFormStore(context.formId, (state) =>\n    state.controlledFields.getValue(field)\n  );\n  const isFormHydrated = useFormStore(\n    context.formId,\n    (state) => state.isHydrated\n  );\n  const defaultValue = useFieldDefaultValue(field, context);\n\n  return isFormHydrated ? value : defaultValue;\n};\n\nexport const useRegisterControlledField = (\n  context: InternalFormContextValue,\n  field: string\n) => {\n  const resolveUpdate = useFormStore(\n    context.formId,\n    (state) => state.controlledFields.valueUpdateResolvers[field]\n  );\n  useEffect(() => {\n    resolveUpdate?.();\n  }, [resolveUpdate]);\n\n  const register = useFormStore(\n    context.formId,\n    (state) => state.controlledFields.register\n  );\n  const unregister = useFormStore(\n    context.formId,\n    (state) => state.controlledFields.unregister\n  );\n  useEffect(() => {\n    register(field);\n    return () => unregister(field);\n  }, [context.formId, field, register, unregister]);\n};\n\nexport const useControllableValue = (\n  context: InternalFormContextValue,\n  field: string\n) => {\n  useRegisterControlledField(context, field);\n\n  const setControlledFieldValue = useFormStore(\n    context.formId,\n    (state) => state.controlledFields.setValue\n  );\n  const setValue = useCallback(\n    (value: unknown) => setControlledFieldValue(field, value),\n    [field, setControlledFieldValue]\n  );\n\n  const value = useControlledFieldValue(context, field);\n\n  return [value, setValue] as const;\n};\n\nexport const useUpdateControllableValue = (formId: InternalFormId) => {\n  const setValue = useFormStore(\n    formId,\n    (state) => state.controlledFields.setValue\n  );\n  return useCallback(\n    (field: string, value: unknown) => setValue(field, value),\n    [setValue]\n  );\n};\n\nexport const useAwaitValue = (formId: InternalFormId) => {\n  const awaitValue = useFormStore(\n    formId,\n    (state) => state.controlledFields.awaitValueUpdate\n  );\n  return useCallback((field: string) => awaitValue(field), [awaitValue]);\n};\n","import { json } from \"@remix-run/server-runtime\";\nimport {\n  formDefaultValuesKey,\n  FORM_DEFAULTS_FIELD,\n} from \"./internal/constants\";\nimport {\n  ValidatorError,\n  ValidationErrorResponseData,\n} from \"./validation/types\";\n\n/**\n * Takes the errors from a `Validator` and returns a `Response`.\n * When you return this from your action, `ValidatedForm` on the frontend will automatically\n * display the errors on the correct fields on the correct form.\n *\n * You can also provide a second argument to `validationError`\n * to specify how to repopulate the form when JS is disabled.\n *\n * @example\n * ```ts\n * const result = validator.validate(await request.formData());\n * if (result.error) return validationError(result.error, result.submittedData);\n * ```\n */\nexport function validationError(\n  error: ValidatorError,\n  repopulateFields?: unknown,\n  init?: ResponseInit\n) {\n  return json<ValidationErrorResponseData>(\n    {\n      fieldErrors: error.fieldErrors,\n      subaction: error.subaction,\n      repopulateFields,\n      formId: error.formId,\n    },\n    { status: 422, ...init }\n  );\n}\n\nexport type FormDefaults = {\n  [formDefaultsKey: `${typeof FORM_DEFAULTS_FIELD}_${string}`]: any;\n};\n\n// FIXME: Remove after https://github.com/egoist/tsup/issues/813 is fixed\nexport type internal_FORM_DEFAULTS_FIELD = typeof FORM_DEFAULTS_FIELD;\n\nexport const setFormDefaults = <DataType = any>(\n  formId: string,\n  defaultValues: Partial<DataType>\n): FormDefaults => ({\n  [formDefaultValuesKey(formId)]: defaultValues,\n});\n","import {\n  FetcherWithComponents,\n  Form as RemixForm,\n  FormMethod,\n  useSubmit,\n  SubmitOptions,\n  FormEncType,\n} from \"@remix-run/react\";\nimport React, {\n  ComponentProps,\n  FormEvent,\n  RefObject,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport * as R from \"remeda\";\nimport { useIsSubmitting, useIsValid } from \"./hooks\";\nimport { FORM_ID_FIELD } from \"./internal/constants\";\nimport {\n  InternalFormContext,\n  InternalFormContextValue,\n} from \"./internal/formContext\";\nimport {\n  useDefaultValuesFromLoader,\n  useErrorResponseForForm,\n  useHasActiveFormSubmit,\n  useSetFieldErrors,\n} from \"./internal/hooks\";\nimport { MultiValueMap, useMultiValueMap } from \"./internal/MultiValueMap\";\nimport {\n  SyncedFormProps,\n  useRootFormStore,\n} from \"./internal/state/createFormStore\";\nimport { useFormStore } from \"./internal/state/storeHooks\";\nimport { useSubmitComplete } from \"./internal/submissionCallbacks\";\nimport {\n  mergeRefs,\n  useDeepEqualsMemo,\n  useIsomorphicLayoutEffect as useLayoutEffect,\n} from \"./internal/util\";\nimport { FieldErrors, Validator } from \"./validation/types\";\n\ntype DeepPartial<T> = T extends object\n  ? {\n      [P in keyof T]?: DeepPartial<T[P]>;\n    }\n  : T;\n\ntype SubactionData<\n  DataType,\n  Subaction extends string | undefined\n> = DataType & { subaction: Subaction };\n\n// Not all validation libraries support encoding a literal value in the schema type (e.g. yup).\n// This condition here allows us to provide strictness for users who are using a validation library that does support it,\n// but also allows us to support users who are using a validation library that doesn't support it.\ntype DataForSubaction<\n  DataType,\n  Subaction extends string | undefined\n> = Subaction extends string // Not all validation libraries support encoding a literal value in the schema type.\n  ? SubactionData<DataType, Subaction> extends undefined\n    ? DataType\n    : SubactionData<DataType, Subaction>\n  : DataType;\n\nexport type FormProps<DataType, Subaction extends string | undefined> = {\n  /**\n   * A `Validator` object that describes how to validate the form.\n   */\n  validator: Validator<DataType>;\n  /**\n   * A submit callback that gets called when the form is submitted\n   * after all validations have been run.\n   */\n  onSubmit?: (\n    data: DataForSubaction<DataType, Subaction>,\n    event: React.FormEvent<HTMLFormElement>\n  ) => void | Promise<void>;\n  /**\n   * Allows you to provide a `fetcher` from Remix's `useFetcher` hook.\n   * The form will use the fetcher for loading states, action data, etc\n   * instead of the default form action.\n   */\n  fetcher?: FetcherWithComponents<any>;\n  /**\n   * Accepts an object of default values for the form\n   * that will automatically be propagated to the form fields via `useField`.\n   */\n  defaultValues?: DeepPartial<DataForSubaction<DataType, Subaction>>;\n  /**\n   * A ref to the form element.\n   */\n  formRef?: React.RefObject<HTMLFormElement>;\n  /**\n   * An optional sub-action to use for the form.\n   * Setting a value here will cause the form to be submitted with an extra `subaction` value.\n   * This can be useful when there are multiple forms on the screen handled by the same action.\n   */\n  subaction?: Subaction;\n  /**\n   * Reset the form to the default values after the form has been successfully submitted.\n   * This is useful if you want to submit the same form multiple times,\n   * and don't redirect in-between submissions.\n   */\n  resetAfterSubmit?: boolean;\n  /**\n   * Normally, the first invalid input will be focused when the validation fails on form submit.\n   * Set this to `false` to disable this behavior.\n   */\n  disableFocusOnError?: boolean;\n} & Omit<ComponentProps<typeof RemixForm>, \"onSubmit\">;\n\nconst getDataFromForm = (el: HTMLFormElement) => new FormData(el);\n\nfunction nonNull<T>(value: T | null | undefined): value is T {\n  return value !== null;\n}\n\nconst focusFirstInvalidInput = (\n  fieldErrors: FieldErrors,\n  customFocusHandlers: MultiValueMap<string, () => void>,\n  formElement: HTMLFormElement\n) => {\n  const namesInOrder = [...formElement.elements]\n    .map((el) => {\n      const input = el instanceof RadioNodeList ? el[0] : el;\n      if (input instanceof HTMLElement && \"name\" in input)\n        return (input as any).name;\n      return null;\n    })\n    .filter(nonNull)\n    .filter((name) => name in fieldErrors);\n  const uniqueNamesInOrder = R.uniq(namesInOrder);\n\n  for (const fieldName of uniqueNamesInOrder) {\n    if (customFocusHandlers.has(fieldName)) {\n      customFocusHandlers.getAll(fieldName).forEach((handler) => {\n        handler();\n      });\n      break;\n    }\n\n    const elem = formElement.elements.namedItem(fieldName);\n    if (!elem) continue;\n\n    if (elem instanceof RadioNodeList) {\n      const selectedRadio =\n        [...elem]\n          .filter(\n            (item): item is HTMLInputElement => item instanceof HTMLInputElement\n          )\n          .find((item) => item.value === elem.value) ?? elem[0];\n      if (selectedRadio && selectedRadio instanceof HTMLInputElement) {\n        selectedRadio.focus();\n        break;\n      }\n    }\n\n    if (elem instanceof HTMLElement) {\n      if (elem instanceof HTMLInputElement && elem.type === \"hidden\") {\n        continue;\n      }\n\n      elem.focus();\n      break;\n    }\n  }\n};\n\nconst useFormId = (providedId?: string): string | symbol => {\n  // We can use a `Symbol` here because we only use it after hydration\n  const [symbolId] = useState(() => Symbol(\"remix-validated-form-id\"));\n  return providedId ?? symbolId;\n};\n\n/**\n * Use a component to access the state so we don't cause\n * any extra rerenders of the whole form.\n */\nconst FormResetter = ({\n  resetAfterSubmit,\n  formRef,\n}: {\n  resetAfterSubmit: boolean;\n  formRef: RefObject<HTMLFormElement>;\n}) => {\n  const isSubmitting = useIsSubmitting();\n  const isValid = useIsValid();\n  useSubmitComplete(isSubmitting, () => {\n    if (isValid && resetAfterSubmit) {\n      formRef.current?.reset();\n    }\n  });\n  return null;\n};\n\nfunction formEventProxy<T extends object>(event: T): T {\n  let defaultPrevented = false;\n  return new Proxy(event, {\n    get: (target, prop) => {\n      if (prop === \"preventDefault\") {\n        return () => {\n          defaultPrevented = true;\n        };\n      }\n\n      if (prop === \"defaultPrevented\") {\n        return defaultPrevented;\n      }\n\n      return target[prop as keyof T];\n    },\n  }) as T;\n}\n\ntype HTMLSubmitEvent = React.BaseSyntheticEvent<\n  SubmitEvent,\n  Event,\n  HTMLFormElement\n>;\n\ntype HTMLFormSubmitter = HTMLButtonElement | HTMLInputElement;\n\n/**\n * The primary form component of `remix-validated-form`.\n */\nexport function ValidatedForm<\n  DataType extends { [fieldName: string]: any },\n  Subaction extends string | undefined\n>({\n  validator,\n  onSubmit,\n  children,\n  fetcher,\n  action,\n  defaultValues: unMemoizedDefaults,\n  formRef: formRefProp,\n  onReset,\n  subaction,\n  resetAfterSubmit = false,\n  disableFocusOnError,\n  method,\n  replace,\n  id,\n  preventScrollReset,\n  relative,\n  encType,\n  ...rest\n}: FormProps<DataType, Subaction>) {\n  const formId = useFormId(id);\n  const providedDefaultValues = useDeepEqualsMemo(unMemoizedDefaults);\n  const contextValue = useMemo<InternalFormContextValue>(\n    () => ({\n      formId,\n      action,\n      subaction,\n      defaultValuesProp: providedDefaultValues,\n      fetcher,\n    }),\n    [action, fetcher, formId, providedDefaultValues, subaction]\n  );\n  const backendError = useErrorResponseForForm(contextValue);\n  const backendDefaultValues = useDefaultValuesFromLoader(contextValue);\n  const hasActiveSubmission = useHasActiveFormSubmit(contextValue);\n  const formRef = useRef<HTMLFormElement>(null);\n  const Form = fetcher?.Form ?? RemixForm;\n\n  const submit = useSubmit();\n  const setFieldErrors = useSetFieldErrors(formId);\n  const setFieldError = useFormStore(formId, (state) => state.setFieldError);\n  const reset = useFormStore(formId, (state) => state.reset);\n  const startSubmit = useFormStore(formId, (state) => state.startSubmit);\n  const endSubmit = useFormStore(formId, (state) => state.endSubmit);\n  const syncFormProps = useFormStore(formId, (state) => state.syncFormProps);\n  const setFormElementInState = useFormStore(\n    formId,\n    (state) => state.setFormElement\n  );\n  const cleanupForm = useRootFormStore((state) => state.cleanupForm);\n  const registerForm = useRootFormStore((state) => state.registerForm);\n\n  const customFocusHandlers = useMultiValueMap<string, () => void>();\n  const registerReceiveFocus: SyncedFormProps[\"registerReceiveFocus\"] =\n    useCallback(\n      (fieldName, handler) => {\n        customFocusHandlers().add(fieldName, handler);\n        return () => {\n          customFocusHandlers().remove(fieldName, handler);\n        };\n      },\n      [customFocusHandlers]\n    );\n\n  // TODO: all these hooks running at startup cause extra, unnecessary renders\n  // There must be a nice way to avoid this.\n  useLayoutEffect(() => {\n    registerForm(formId);\n    return () => cleanupForm(formId);\n  }, [cleanupForm, formId, registerForm]);\n\n  useLayoutEffect(() => {\n    syncFormProps({\n      action,\n      defaultValues: providedDefaultValues ?? backendDefaultValues ?? {},\n      subaction,\n      registerReceiveFocus,\n      validator,\n    });\n  }, [\n    action,\n    providedDefaultValues,\n    registerReceiveFocus,\n    subaction,\n    syncFormProps,\n    backendDefaultValues,\n    validator,\n  ]);\n\n  useLayoutEffect(() => {\n    setFormElementInState(formRef.current);\n  }, [setFormElementInState]);\n\n  useEffect(() => {\n    setFieldErrors(backendError?.fieldErrors ?? {});\n    if (!disableFocusOnError && backendError?.fieldErrors) {\n      focusFirstInvalidInput(\n        backendError.fieldErrors,\n        customFocusHandlers(),\n        formRef.current!\n      );\n    }\n  }, [\n    backendError?.fieldErrors,\n    customFocusHandlers,\n    disableFocusOnError,\n    setFieldErrors,\n    setFieldError,\n  ]);\n\n  useSubmitComplete(hasActiveSubmission, () => {\n    endSubmit();\n  });\n\n  const handleSubmit = async (\n    e: FormEvent<HTMLFormElement>,\n    target: typeof e.currentTarget,\n    nativeEvent: HTMLSubmitEvent[\"nativeEvent\"]\n  ) => {\n    startSubmit();\n    const submitter = nativeEvent.submitter as HTMLFormSubmitter | null;\n    const formMethod = (submitter?.formMethod as FormMethod) || method;\n    const formData = getDataFromForm(target);\n    if (submitter?.name) {\n      formData.append(submitter.name, submitter.value);\n    }\n\n    const result = await validator.validate(formData);\n    if (result.error) {\n      setFieldErrors(result.error.fieldErrors);\n      endSubmit();\n      if (!disableFocusOnError) {\n        focusFirstInvalidInput(\n          result.error.fieldErrors,\n          customFocusHandlers(),\n          formRef.current!\n        );\n      }\n    } else {\n      setFieldErrors({});\n      const eventProxy = formEventProxy(e);\n      await onSubmit?.(result.data as any, eventProxy);\n      if (eventProxy.defaultPrevented) {\n        endSubmit();\n        return;\n      }\n\n      const opts: SubmitOptions = {\n        method: formMethod,\n        replace,\n        preventScrollReset,\n        relative,\n        action,\n        encType: encType as FormEncType | undefined,\n      };\n\n      // We deviate from the Remix code here a bit because of our async submit.\n      // In Remix's `FormImpl`, they use `event.currentTarget` to get the form,\n      // but we already have the form in `formRef.current` so we can just use that.\n      // If we use `event.currentTarget` here, it will break because `currentTarget`\n      // will have changed since the start of the submission.\n      if (fetcher) fetcher.submit(formData, opts);\n      else submit(formData, opts);\n    }\n  };\n\n  return (\n    <Form\n      ref={mergeRefs([formRef, formRefProp])}\n      {...rest}\n      id={id}\n      action={action}\n      method={method}\n      encType={encType}\n      replace={replace}\n      preventScrollReset={preventScrollReset}\n      relative={relative}\n      onSubmit={(e) => {\n        e.preventDefault();\n        handleSubmit(\n          e,\n          e.currentTarget,\n          (e as unknown as HTMLSubmitEvent).nativeEvent\n        );\n      }}\n      onReset={(event) => {\n        onReset?.(event);\n        if (event.defaultPrevented) return;\n        reset();\n      }}\n    >\n      <InternalFormContext.Provider value={contextValue}>\n        <>\n          <FormResetter formRef={formRef} resetAfterSubmit={resetAfterSubmit} />\n          {subaction && (\n            <input type=\"hidden\" value={subaction} name=\"subaction\" />\n          )}\n          {id && <input type=\"hidden\" value={id} name={FORM_ID_FIELD} />}\n          {children}\n        </>\n      </InternalFormContext.Provider>\n    </Form>\n  );\n}\n","import { useCallback, useRef } from \"react\";\n\nexport class MultiValueMap<Key, Value> {\n  private dict: Map<Key, Value[]> = new Map();\n\n  add = (key: Key, value: Value) => {\n    if (this.dict.has(key)) {\n      this.dict.get(key)!.push(value);\n    } else {\n      this.dict.set(key, [value]);\n    }\n  };\n\n  delete = (key: Key) => {\n    this.dict.delete(key);\n  };\n\n  remove = (key: Key, value: Value) => {\n    if (!this.dict.has(key)) return;\n    const array = this.dict.get(key)!;\n    const index = array.indexOf(value);\n    if (index !== -1) array.splice(index, 1);\n    if (array.length === 0) this.dict.delete(key);\n  };\n\n  getAll = (key: Key): Value[] => {\n    return this.dict.get(key) ?? [];\n  };\n\n  entries = (): IterableIterator<[Key, Value[]]> => this.dict.entries();\n\n  values = (): IterableIterator<Value[]> => this.dict.values();\n\n  has = (key: Key): boolean => this.dict.has(key);\n}\n\nexport const useMultiValueMap = <Key, Value>() => {\n  const ref = useRef<MultiValueMap<Key, Value> | null>(null);\n  return useCallback(() => {\n    if (ref.current) return ref.current;\n    ref.current = new MultiValueMap();\n    return ref.current;\n  }, []);\n};\n","import { useEffect, useRef } from \"react\";\n\nexport function useSubmitComplete(isSubmitting: boolean, callback: () => void) {\n  const isPending = useRef(false);\n  useEffect(() => {\n    if (isSubmitting) {\n      isPending.current = true;\n    }\n\n    if (!isSubmitting && isPending.current) {\n      isPending.current = false;\n      callback();\n    }\n  });\n}\n","import type React from \"react\";\nimport { useEffect, useLayoutEffect, useRef } from \"react\";\nimport * as R from \"remeda\";\n\nexport const omit = (obj: any, ...keys: string[]) => {\n  const result = { ...obj };\n  for (const key of keys) {\n    delete result[key];\n  }\n  return result;\n};\n\nexport const mergeRefs = <T = any>(\n  refs: Array<React.MutableRefObject<T> | React.LegacyRef<T> | undefined>\n): React.RefCallback<T> => {\n  return (value: T) => {\n    refs.filter(Boolean).forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        (ref as React.MutableRefObject<T | null>).current = value;\n      }\n    });\n  };\n};\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\nexport const useDeepEqualsMemo = <T>(item: T): T => {\n  const ref = useRef<T>(item);\n  const areEqual = ref.current === item || R.equals(ref.current, item);\n  useEffect(() => {\n    if (!areEqual) {\n      ref.current = item;\n    }\n  });\n  return areEqual ? ref.current : item;\n};\n","import * as R from \"remeda\";\nimport { CreateValidatorArg, GenericObject, Validator } from \"..\";\nimport { FORM_ID_FIELD } from \"../internal/constants\";\nimport { objectFromPathEntries } from \"../internal/flatten\";\n\nconst preprocessFormData = (data: GenericObject | FormData): GenericObject => {\n  // A slightly janky way of determining if the data is a FormData object\n  // since node doesn't really have FormData\n  if (\"entries\" in data && typeof data.entries === \"function\")\n    return objectFromPathEntries([...data.entries()]);\n  return objectFromPathEntries(Object.entries(data));\n};\n\nconst omitInternalFields = (data: GenericObject): GenericObject =>\n  R.omit(data, [FORM_ID_FIELD]);\n\n/**\n * Used to create a validator for a form.\n * It provides built-in handling for unflattening nested objects and\n * extracting the values from FormData.\n */\nexport function createValidator<T>(\n  validator: CreateValidatorArg<T>\n): Validator<T> {\n  return {\n    validate: async (value) => {\n      const data = preprocessFormData(value);\n      const result = await validator.validate(omitInternalFields(data));\n\n      if (result.error) {\n        return {\n          data: undefined,\n          error: {\n            fieldErrors: result.error,\n            subaction: data.subaction,\n            formId: data[FORM_ID_FIELD],\n          },\n          submittedData: data,\n          formId: data[FORM_ID_FIELD],\n        };\n      }\n\n      return {\n        data: result.data,\n        error: undefined,\n        submittedData: data,\n        formId: data[FORM_ID_FIELD],\n      };\n    },\n    validateField: (data: GenericObject | FormData, field: string) =>\n      validator.validateField(preprocessFormData(data), field),\n  };\n}\n","import { setPath } from \"set-get\";\nimport { MultiValueMap } from \"./MultiValueMap\";\n\nexport const objectFromPathEntries = (entries: [string, any][]) => {\n  const map = new MultiValueMap<string, any>();\n  entries.forEach(([key, value]) => map.add(key, value));\n  return [...map.entries()].reduce(\n    (acc, [key, value]) =>\n      setPath(acc, key, value.length === 1 ? value[0] : value),\n    {} as Record<string, any>\n  );\n};\n","import { useCallback, useMemo } from \"react\";\nimport {\n  useInternalFormContext,\n  useRegisterReceiveFocus,\n} from \"./internal/hooks\";\nimport { useFormHelpers, useFormState } from \"./unreleased/formStateHooks\";\nimport {\n  FieldErrors,\n  TouchedFields,\n  ValidationResult,\n} from \"./validation/types\";\n\nexport type FormContextValue = {\n  /**\n   * All the errors in all the fields in the form.\n   */\n  fieldErrors: FieldErrors;\n  /**\n   * Clear the errors of the specified fields.\n   */\n  clearError: (...names: string[]) => void;\n  /**\n   * Validate the specified field.\n   */\n  validateField: (fieldName: string) => Promise<string | null>;\n  /**\n   * The `action` prop of the form.\n   */\n  action?: string;\n  /**\n   * The `subaction` prop of the form.\n   */\n  subaction?: string;\n  /**\n   * Whether or not the form is submitting.\n   */\n  isSubmitting: boolean;\n  /**\n   * Whether or not a submission has been attempted.\n   * This is true once the form has been submitted, even if there were validation errors.\n   * Resets to false when the form is reset.\n   */\n  hasBeenSubmitted: boolean;\n  /**\n   * Whether or not the form is valid.\n   */\n  isValid: boolean;\n  /**\n   * The default values of the form.\n   */\n  defaultValues?: { [fieldName: string]: any };\n  /**\n   * Register a custom focus handler to be used when\n   * the field needs to receive focus due to a validation error.\n   */\n  registerReceiveFocus: (fieldName: string, handler: () => void) => () => void;\n  /**\n   * Any fields that have been touched by the user.\n   */\n  touchedFields: TouchedFields;\n  /**\n   * Change the touched state of the specified field.\n   */\n  setFieldTouched: (fieldName: string, touched: boolean) => void;\n  /**\n   * Validate the whole form and populate any errors.\n   */\n  validate: () => Promise<ValidationResult<unknown>>;\n  /**\n   * Clears all errors on the form.\n   */\n  clearAllErrors: () => void;\n  /**\n   * Resets the form.\n   *\n   * _Note_: The equivalent behavior can be achieved by calling formElement.reset()\n   * or clicking a button element with `type=\"reset\"`.\n   */\n  reset: () => void;\n  /**\n   * Submits the form, running all validations first.\n   *\n   * _Note_: This is equivalent to clicking a button element with `type=\"submit\"` or calling formElement.submit().\n   */\n  submit: () => void;\n  /**\n   * Returns the current form values as FormData\n   */\n  getValues: () => FormData;\n};\n\n/**\n * Provides access to some of the internal state of the form.\n */\nexport const useFormContext = (formId?: string): FormContextValue => {\n  // Try to access context so we get our error specific to this hook if it's not there\n  const context = useInternalFormContext(formId, \"useFormContext\");\n  const state = useFormState(formId);\n  const {\n    clearError: internalClearError,\n    setTouched,\n    validateField,\n    clearAllErrors,\n    validate,\n    reset,\n    submit,\n    getValues,\n  } = useFormHelpers(formId);\n\n  const registerReceiveFocus = useRegisterReceiveFocus(context.formId);\n\n  const clearError = useCallback(\n    (...names: string[]) => {\n      names.forEach((name) => {\n        internalClearError(name);\n      });\n    },\n    [internalClearError]\n  );\n\n  return useMemo(\n    () => ({\n      ...state,\n      setFieldTouched: setTouched,\n      validateField,\n      clearError,\n      registerReceiveFocus,\n      clearAllErrors,\n      validate,\n      reset,\n      submit,\n      getValues,\n    }),\n    [\n      clearAllErrors,\n      clearError,\n      registerReceiveFocus,\n      reset,\n      setTouched,\n      state,\n      submit,\n      validate,\n      validateField,\n      getValues,\n    ]\n  );\n};\n","import { useMemo } from \"react\";\nimport {} from \"../internal/getInputProps\";\nimport {\n  useInternalFormContext,\n  useClearError,\n  useSetTouched,\n  useDefaultValuesForForm,\n  useFieldErrorsForForm,\n  useInternalIsSubmitting,\n  useInternalHasBeenSubmitted,\n  useTouchedFields,\n  useInternalIsValid,\n  useFieldErrors,\n  useValidate,\n  useSetFieldErrors,\n  useResetFormElement,\n  useSyncedDefaultValues,\n  useFormActionProp,\n  useFormSubactionProp,\n  useSubmitForm,\n  useFormValues,\n  useSmartValidate,\n} from \"../internal/hooks\";\nimport {\n  FieldErrors,\n  TouchedFields,\n  ValidationResult,\n} from \"../validation/types\";\n\nexport type FormState = {\n  fieldErrors: FieldErrors;\n  isSubmitting: boolean;\n  hasBeenSubmitted: boolean;\n  touchedFields: TouchedFields;\n  defaultValues: { [fieldName: string]: any };\n  action?: string;\n  subaction?: string;\n  isValid: boolean;\n};\n\n/**\n * Returns information about the form.\n *\n * @param formId the id of the form. Only necessary if being used outside a ValidatedForm.\n */\nexport const useFormState = (formId?: string): FormState => {\n  const formContext = useInternalFormContext(formId, \"useFormState\");\n  const isSubmitting = useInternalIsSubmitting(formContext.formId);\n  const hasBeenSubmitted = useInternalHasBeenSubmitted(formContext.formId);\n  const touchedFields = useTouchedFields(formContext.formId);\n  const isValid = useInternalIsValid(formContext.formId);\n  const action = useFormActionProp(formContext.formId);\n  const subaction = useFormSubactionProp(formContext.formId);\n\n  const syncedDefaultValues = useSyncedDefaultValues(formContext.formId);\n  const defaultValuesToUse = useDefaultValuesForForm(formContext);\n  const hydratedDefaultValues =\n    defaultValuesToUse.hydrateTo(syncedDefaultValues);\n\n  const fieldErrorsFromState = useFieldErrors(formContext.formId);\n  const fieldErrorsToUse = useFieldErrorsForForm(formContext);\n  const hydratedFieldErrors = fieldErrorsToUse.hydrateTo(fieldErrorsFromState);\n\n  return useMemo(\n    () => ({\n      action,\n      subaction,\n      defaultValues: hydratedDefaultValues,\n      fieldErrors: hydratedFieldErrors ?? {},\n      hasBeenSubmitted,\n      isSubmitting,\n      touchedFields,\n      isValid,\n    }),\n    [\n      action,\n      hasBeenSubmitted,\n      hydratedDefaultValues,\n      hydratedFieldErrors,\n      isSubmitting,\n      isValid,\n      subaction,\n      touchedFields,\n    ]\n  );\n};\n\nexport type FormHelpers = {\n  /**\n   * Clear the error of the specified field.\n   */\n  clearError: (fieldName: string) => void;\n  /**\n   * Validate the specified field.\n   */\n  validateField: (fieldName: string) => Promise<string | null>;\n  /**\n   * Change the touched state of the specified field.\n   */\n  setTouched: (fieldName: string, touched: boolean) => void;\n  /**\n   * Validate the whole form and populate any errors.\n   */\n  validate: () => Promise<ValidationResult<unknown>>;\n  /**\n   * Clears all errors on the form.\n   */\n  clearAllErrors: () => void;\n  /**\n   * Resets the form.\n   *\n   * _Note_: The equivalent behavior can be achieved by calling formElement.reset()\n   * or clicking a button element with `type=\"reset\"`.\n   */\n  reset: () => void;\n  /**\n   * Submits the form, running all validations first.\n   *\n   * _Note_: This is equivalent to clicking a button element with `type=\"submit\"` or calling formElement.submit().\n   */\n  submit: () => void;\n  /**\n   * Returns the current form values as FormData\n   */\n  getValues: () => FormData;\n};\n\n/**\n * Returns helpers that can be used to update the form state.\n *\n * @param formId the id of the form. Only necessary if being used outside a ValidatedForm.\n */\nexport const useFormHelpers = (formId?: string): FormHelpers => {\n  const formContext = useInternalFormContext(formId, \"useFormHelpers\");\n  const setTouched = useSetTouched(formContext);\n  const validateField = useSmartValidate(formContext.formId);\n  const validate = useValidate(formContext.formId);\n  const clearError = useClearError(formContext);\n  const setFieldErrors = useSetFieldErrors(formContext.formId);\n  const reset = useResetFormElement(formContext.formId);\n  const submit = useSubmitForm(formContext.formId);\n  const getValues = useFormValues(formContext.formId);\n  return useMemo(\n    () => ({\n      setTouched,\n      validateField: async (fieldName: string) => {\n        const res = await validateField({\n          alwaysIncludeErrorsFromFields: [fieldName],\n        });\n        return res.error?.fieldErrors[fieldName] ?? null;\n      },\n      clearError,\n      validate,\n      clearAllErrors: () => setFieldErrors({}),\n      reset,\n      submit,\n      getValues,\n    }),\n    [\n      clearError,\n      reset,\n      setFieldErrors,\n      setTouched,\n      submit,\n      validate,\n      validateField,\n      getValues,\n    ]\n  );\n};\n","import { nanoid } from \"nanoid\";\nimport React, { useMemo, useRef, useState } from \"react\";\nimport { useCallback } from \"react\";\nimport invariant from \"tiny-invariant\";\nimport { InternalFormContextValue } from \"../formContext\";\nimport {\n  useFieldDefaultValue,\n  useFieldError,\n  useInternalFormContext,\n  useInternalHasBeenSubmitted,\n  useSmartValidate,\n} from \"../hooks\";\nimport * as arrayUtil from \"./arrayUtil\";\nimport { useRegisterControlledField } from \"./controlledFields\";\nimport { useFormStore } from \"./storeHooks\";\n\nexport type FieldArrayValidationBehavior = \"onChange\" | \"onSubmit\";\n\nexport type FieldArrayValidationBehaviorOptions = {\n  initial: FieldArrayValidationBehavior;\n  whenSubmitted: FieldArrayValidationBehavior;\n};\n\nexport type FieldArrayItem<T> = {\n  /**\n   * The default value of the item.\n   * This does not update as the field is changed by the user.\n   */\n  defaultValue: T;\n  /**\n   * A unique key for the item.\n   * Use this as the key prop when rendering the item.\n   */\n  key: string;\n};\n\nconst useInternalFieldArray = (\n  context: InternalFormContextValue,\n  field: string,\n  validationBehavior?: Partial<FieldArrayValidationBehaviorOptions>\n) => {\n  const value = useFieldDefaultValue(field, context);\n  useRegisterControlledField(context, field);\n  const hasBeenSubmitted = useInternalHasBeenSubmitted(context.formId);\n  const validateField = useSmartValidate(context.formId);\n  const error = useFieldError(field, context);\n\n  const resolvedValidationBehavior: FieldArrayValidationBehaviorOptions = {\n    initial: \"onSubmit\",\n    whenSubmitted: \"onChange\",\n    ...validationBehavior,\n  };\n\n  const behavior = hasBeenSubmitted\n    ? resolvedValidationBehavior.whenSubmitted\n    : resolvedValidationBehavior.initial;\n\n  const maybeValidate = useCallback(() => {\n    if (behavior === \"onChange\") {\n      validateField({ alwaysIncludeErrorsFromFields: [field] });\n    }\n  }, [behavior, field, validateField]);\n\n  invariant(\n    value === undefined || value === null || Array.isArray(value),\n    `FieldArray: defaultValue value for ${field} must be an array, null, or undefined`\n  );\n\n  const arr = useFormStore(\n    context.formId,\n    (state) => state.controlledFields.array\n  );\n\n  const arrayValue = useMemo<unknown[]>(() => value ?? [], [value]);\n  const keyRef = useRef<string[]>([]);\n\n  // If the lengths don't match up it means one of two things\n  // 1. The array has been modified outside of this hook\n  // 2. We're initializing the array\n  if (keyRef.current.length !== arrayValue.length) {\n    keyRef.current = arrayValue.map(() => nanoid());\n  }\n\n  const helpers = useMemo(\n    () => ({\n      push: (item: any) => {\n        arr.push(field, item);\n        keyRef.current.push(nanoid());\n        maybeValidate();\n      },\n      swap: (indexA: number, indexB: number) => {\n        arr.swap(field, indexA, indexB);\n        arrayUtil.swap(keyRef.current, indexA, indexB);\n        maybeValidate();\n      },\n      move: (from: number, to: number) => {\n        arr.move(field, from, to);\n        arrayUtil.move(keyRef.current, from, to);\n        maybeValidate();\n      },\n      insert: (index: number, value: any) => {\n        arr.insert(field, index, value);\n        arrayUtil.insert(keyRef.current, index, nanoid());\n        maybeValidate();\n      },\n      unshift: (value: any) => {\n        arr.unshift(field, value);\n        keyRef.current.unshift(nanoid());\n        maybeValidate();\n      },\n      remove: (index: number) => {\n        arr.remove(field, index);\n        arrayUtil.remove(keyRef.current, index);\n        maybeValidate();\n      },\n      pop: () => {\n        arr.pop(field);\n        keyRef.current.pop();\n        maybeValidate();\n      },\n      replace: (index: number, value: any) => {\n        arr.replace(field, index, value);\n        keyRef.current[index] = nanoid();\n        maybeValidate();\n      },\n    }),\n    [arr, field, maybeValidate]\n  );\n\n  const valueWithKeys = useMemo(() => {\n    const result: { defaultValue: any; key: string }[] = [];\n    arrayValue.forEach((item, index) => {\n      result[index] = {\n        key: keyRef.current[index],\n        defaultValue: item,\n      };\n    });\n    return result;\n  }, [arrayValue]);\n\n  return [valueWithKeys, helpers, error] as const;\n};\n\nexport type FieldArrayHelpers<Item = any> = {\n  push: (item: Item) => void;\n  swap: (indexA: number, indexB: number) => void;\n  move: (from: number, to: number) => void;\n  insert: (index: number, value: Item) => void;\n  unshift: (value: Item) => void;\n  remove: (index: number) => void;\n  pop: () => void;\n  replace: (index: number, value: Item) => void;\n};\n\nexport type UseFieldArrayOptions = {\n  formId?: string;\n  validationBehavior?: Partial<FieldArrayValidationBehaviorOptions>;\n};\n\nexport function useFieldArray<Item = any>(\n  name: string,\n  { formId, validationBehavior }: UseFieldArrayOptions = {}\n) {\n  const context = useInternalFormContext(formId, \"FieldArray\");\n\n  return useInternalFieldArray(context, name, validationBehavior) as [\n    items: FieldArrayItem<Item>[],\n    helpers: FieldArrayHelpers,\n    error: string | undefined\n  ];\n}\n\nexport type FieldArrayProps<Item> = {\n  name: string;\n  children: (\n    items: FieldArrayItem<Item>[],\n    helpers: FieldArrayHelpers<Item>,\n    error: string | undefined\n  ) => React.ReactNode;\n  formId?: string;\n  validationBehavior?: FieldArrayValidationBehaviorOptions;\n};\n\nexport function FieldArray<Item = any>({\n  name,\n  children,\n  formId,\n  validationBehavior,\n}: FieldArrayProps<Item>) {\n  const context = useInternalFormContext(formId, \"FieldArray\");\n  const [value, helpers, error] = useInternalFieldArray(\n    context,\n    name,\n    validationBehavior\n  );\n  return <>{children(value, helpers, error)}</>;\n}\n"],"mappings":"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","names":["import_react","import_react","get","import_tiny_invariant","hydratedData","import_tiny_invariant","invariant","from","get","invariant","_a","from","state","match","invariant","touched","state","fieldErrors","import_react","value","import_react","R","import_react","import_react","import_react","R","replace","RemixForm","_a","R","import_react","import_react","import_react","import_tiny_invariant","import_jsx_runtime","invariant","from","value"]}