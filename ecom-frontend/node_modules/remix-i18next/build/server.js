"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemixI18Next = void 0;
const accept_language_parser_1 = require("accept-language-parser");
const i18next_1 = require("i18next");
const get_client_locales_1 = require("./lib/get-client-locales");
const DEFAULT_NS = "translation";
class RemixI18Next {
    constructor(options) {
        this.options = options;
        this.detector = new LanguageDetector(this.options.detection);
    }
    /**
     * Detect the current locale by following the order defined in the
     * `detection.order` option.
     * By default the order is
     * - searchParams
     * - cookie
     * - session
     * - header
     * And finally the fallback language.
     */
    async getLocale(request) {
        return this.detector.detect(request);
    }
    /**
     * Get the namespaces required by the routes which are going to be rendered
     * when doing SSR.
     *
     * @param context The EntryContext object received by `handleRequest` in entry.server
     *
     * @example
     * await instance.init({
     *   ns: i18n.getRouteNamespaces(context),
     *   // ...more options
     * });
     */
    getRouteNamespaces(context) {
        let namespaces = Object.values(context.routeModules)
            .filter((route) => { var _a; return ((_a = route.handle) === null || _a === void 0 ? void 0 : _a.i18n) !== undefined; })
            .flatMap((route) => {
            let i18n = route.handle.i18n;
            if (typeof i18n === "string")
                return i18n;
            if (!Array.isArray(i18n))
                return [];
            if (i18n.every((ns) => typeof ns === "string"))
                return i18n;
            return [];
        });
        return [...new Set(namespaces)];
    }
    async getFixedT(requestOrLocale, namespaces, options = {}) {
        var _a;
        let parsedNamespaces = namespaces !== null && namespaces !== void 0 ? namespaces : DEFAULT_NS;
        // Make sure there's at least one namespace
        if (!namespaces || namespaces.length === 0) {
            parsedNamespaces = (((_a = this.options.i18next) === null || _a === void 0 ? void 0 : _a.defaultNS) ||
                "translation");
        }
        let [instance, locale] = await Promise.all([
            this.createInstance({
                ...this.options.i18next,
                ...options,
                fallbackNS: parsedNamespaces,
                defaultNS: typeof parsedNamespaces === "string"
                    ? parsedNamespaces
                    : parsedNamespaces[0],
            }),
            typeof requestOrLocale === "string"
                ? requestOrLocale
                : this.getLocale(requestOrLocale),
        ]);
        await instance.changeLanguage(locale);
        await instance.loadNamespaces(parsedNamespaces);
        return instance.getFixedT(locale, parsedNamespaces);
    }
    async createInstance(options = {}) {
        let instance = (0, i18next_1.createInstance)();
        let plugins = [
            ...(this.options.backend ? [this.options.backend] : []),
            ...(this.options.plugins || []),
        ];
        for (const plugin of plugins)
            instance.use(plugin);
        await instance.init(options);
        return instance;
    }
}
exports.RemixI18Next = RemixI18Next;
class LanguageDetector {
    constructor(options) {
        this.options = options;
        this.isSessionOnly(options);
        this.isCookieOnly(options);
    }
    isSessionOnly(options) {
        var _a;
        if (((_a = options.order) === null || _a === void 0 ? void 0 : _a.length) === 1 &&
            options.order[0] === "session" &&
            !options.sessionStorage) {
            throw new Error("You need a sessionStorage if you want to only get the locale from the session");
        }
    }
    isCookieOnly(options) {
        var _a;
        if (((_a = options.order) === null || _a === void 0 ? void 0 : _a.length) === 1 &&
            options.order[0] === "cookie" &&
            !options.cookie) {
            throw new Error("You need a cookie if you want to only get the locale from the cookie");
        }
    }
    async detect(request) {
        var _a;
        let order = (_a = this.options.order) !== null && _a !== void 0 ? _a : [
            "searchParams",
            "cookie",
            "session",
            "header",
        ];
        for (let method of order) {
            let locale = null;
            if (method === "searchParams") {
                locale = await this.fromSearchParams(request);
            }
            if (method === "cookie") {
                locale = await this.fromCookie(request);
            }
            if (method === "session") {
                locale = await this.fromSessionStorage(request);
            }
            if (method === "header") {
                locale = await this.fromHeader(request);
            }
            if (locale)
                return locale;
        }
        return this.options.fallbackLanguage;
    }
    async fromSearchParams(request) {
        var _a, _b;
        let url = new URL(request.url);
        if (!url.searchParams.has((_a = this.options.searchParamKey) !== null && _a !== void 0 ? _a : "lng")) {
            return null;
        }
        return this.fromSupported(url.searchParams.get((_b = this.options.searchParamKey) !== null && _b !== void 0 ? _b : "lng"));
    }
    async fromCookie(request) {
        var _a;
        if (!this.options.cookie)
            return null;
        let cookie = this.options.cookie;
        let lng = (_a = (await cookie.parse(request.headers.get("Cookie")))) !== null && _a !== void 0 ? _a : "";
        if (!lng)
            return null;
        return this.fromSupported(lng);
    }
    async fromSessionStorage(request) {
        var _a;
        if (!this.options.sessionStorage)
            return null;
        let session = await this.options.sessionStorage.getSession(request.headers.get("Cookie"));
        let lng = session.get((_a = this.options.sessionKey) !== null && _a !== void 0 ? _a : "lng");
        if (!lng)
            return null;
        return this.fromSupported(lng);
    }
    async fromHeader(request) {
        let locales = (0, get_client_locales_1.getClientLocales)(request);
        if (!locales)
            return null;
        if (Array.isArray(locales))
            return this.fromSupported(locales.join(","));
        return this.fromSupported(locales);
    }
    fromSupported(language) {
        return ((0, accept_language_parser_1.pick)(this.options.supportedLanguages, language !== null && language !== void 0 ? language : this.options.fallbackLanguage, { loose: false }) ||
            (0, accept_language_parser_1.pick)(this.options.supportedLanguages, language !== null && language !== void 0 ? language : this.options.fallbackLanguage, { loose: true }));
    }
}
